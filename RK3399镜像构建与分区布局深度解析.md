# RK3399 镜像构建与分区布局深度解析

> **适用范围**: OrangePi RK3399 嵌入式 Linux 系统镜像构建
> **核心文件**: `scripts/lib/build_image.sh`, `external/install_to_emmc`
> **前置知识**: 已理解 U-Boot 打包、INI 配置、固件加密原理

---

## 一、RK3399 分区布局的硬件约束

### 1.1 固定分区地址表（Sector 为单位）

RK3399 的分区布局由 **BootROM 硬件要求** 决定，不能随意更改：

| 分区名称 | 起始 Sector | 结束 Sector | 起始地址 | 大小 | 内容 |
|---------|------------|------------|---------|------|------|
| **idbloader** | **64** | - | **32KB** | ~4MB | DDR init + Miniloader（**BootROM 硬编码要求**） |
| uboot | 24576 | 32767 | 12MB | 4MB | U-Boot bootloader |
| trust | 32768 | 40959 | 16MB | 4MB | ARM Trusted Firmware + OP-TEE |
| boot | 49152 | 114687 | 24MB | 32MB | Kernel + Device Tree + Initramfs |
| rootfs | 376832 | -34s | 184MB | 动态 | 根文件系统（ext4） |

**关键约束**：
```bash
# build_image.sh:12-19
LOADER1_START=64        # 硬件要求：BootROM 从 sector 64 读取 idbloader
UBOOT_START=24576       # 24576 * 512B = 12MB
TRUST_START=32768       # 32768 * 512B = 16MB
BOOT_START=49152        # 49152 * 512B = 24MB
ROOTFS_START=376832     # 376832 * 512B = 184MB
```

**为什么 idbloader 必须在 Sector 64？**
- RK3399 的 **BootROM**（芯片内固化程序）硬编码从以下位置搜索启动代码：
  - **SD/eMMC**: Sector 64（32KB 偏移）
  - **SPI NOR Flash**: 地址 0x8000
- 这是 Rockchip 硬件设计，无法更改
- idbloader.img 包含 DDR 初始化代码和 Miniloader，必须放在 BootROM 能找到的位置

---

### 1.2 地址计算公式

```bash
实际字节偏移 = Sector编号 × 512字节

# 示例
LOADER1_START=64        → 64 × 512 = 32768字节 = 32KB
UBOOT_START=24576       → 24576 × 512 = 12582912字节 = 12MB
ROOTFS_START=376832     → 376832 × 512 = 193019904字节 ≈ 184MB
```

---

## 二、GPT 分区表创建流程

### 2.1 为什么用 GPT 而不是 MBR？

**对比 H3/H6（MBR）和 RK3399（GPT）**：

| 特性 | H3/H6（MBR） | RK3399（GPT） |
|------|-------------|--------------|
| 分区表类型 | DOS MBR | GPT |
| 最大分区数 | 4 个主分区 | 128 个分区 |
| 分区大小限制 | 2TB | 18EB |
| Bootloader 存储 | 扇区 8 和 16400（固定） | Sector 64 起（可配置） |
| 分区 UUID | 不支持 | 支持（用于 fstab） |

**RK3399 选择 GPT 的原因**：
1. **安全启动需求** - 支持分区 GUID，便于识别 rootfs
2. **大容量 eMMC** - RK3399 通常配备 ≥16GB eMMC
3. **现代 Linux 标准** - systemd 推荐使用 GPT + UUID 挂载

---

### 2.2 GPT 分区创建代码详解

```bash
# build_image.sh:46-61

# 1. 创建空白镜像文件
dd if=/dev/zero of=${IMAGE} bs=1M count=0 seek=$GPT_IMAGE_SIZE
# 参数解析：
#   - if=/dev/zero: 输入源为零填充
#   - of=${IMAGE}: 输出到镜像文件
#   - bs=1M: 块大小 1MB
#   - count=0: 不写入任何块（只创建稀疏文件）
#   - seek=$GPT_IMAGE_SIZE: 跳到文件末尾，创建指定大小的空文件

# 2. 创建 GPT 分区表
parted -s $IMAGE mklabel gpt
# 参数解析：
#   - -s: 静默模式（不需要交互）
#   - mklabel gpt: 创建 GUID Partition Table

# 3. 创建各个分区（单位：sector）
parted -s $IMAGE unit s mkpart uboot  ${UBOOT_START} ${UBOOT_END}
parted -s $IMAGE unit s mkpart trust  ${TRUST_START} ${TRUST_END}
parted -s $IMAGE unit s mkpart boot   ${BOOT_START}  ${BOOT_END}
parted -s $IMAGE -- unit s mkpart rootfs ${ROOTFS_START} -34s
# 参数解析：
#   - unit s: 使用 sector 为单位
#   - mkpart <name> <start> <end>: 创建分区
#   - -34s: 结束位置为倒数第 34 个 sector（GPT 保留区）

# 4. 设置 rootfs 分区的固定 UUID（用于 /etc/fstab 挂载）
gdisk $IMAGE <<EOF
x                    # 进入专家模式
c                    # 修改分区 GUID
4                    # 选择第 4 个分区（rootfs）
${ROOT_UUID}         # 设置 UUID: 614e0000-0000-4b53-8000-1d28000054a9
w                    # 写入更改
y                    # 确认
EOF
```

**为什么要固定 rootfs 的 UUID？**
```bash
# /etc/fstab 中的挂载配置
UUID=614e0000-0000-4b53-8000-1d28000054a9  /  ext4  defaults  0  1

# 优点：
# 1. 无论设备节点如何变化（/dev/mmcblk0p4 或 /dev/mmcblk1p4），UUID 不变
# 2. 支持多存储设备（SD卡 + eMMC）共存
# 3. 避免设备名冲突导致的启动失败
```

---

## 三、dd 命令详解与镜像组装

### 3.1 dd 命令核心参数

```bash
dd if=<输入文件> of=<输出文件> seek=<偏移> conv=<转换选项>
```

| 参数 | 含义 | 示例 |
|------|------|------|
| `if` | Input File（输入文件） | `if=$BUILD/uboot/uboot.img` |
| `of` | Output File（输出文件） | `of=$IMAGE` |
| `bs` | Block Size（块大小） | `bs=512`（默认，sector 大小） |
| `seek` | 跳过输出文件的前 N 个块 | `seek=24576`（跳到 12MB 处） |
| `skip` | 跳过输入文件的前 N 个块 | `skip=100` |
| `count` | 复制的块数 | `count=1000` |
| `conv` | 转换选项 | `conv=notrunc,fsync` |

**conv 参数详解**：
- `notrunc`: **不截断输出文件**（保留已存在的内容）
  - 如果不加此参数，dd 会清空输出文件再写入
  - 镜像组装时必须使用，否则会覆盖之前写入的分区
- `fsync`: 写入后立即同步到磁盘（确保数据持久化）
- `sync`: 用零填充每个输入块到指定大小

---

### 3.2 镜像组装的完整流程

```bash
# build_image.sh:62-66

# 步骤 1: 写入 idbloader（DDR init + Miniloader）
dd if=$BUILD/uboot/idbloader.img of=$IMAGE seek=$LOADER1_START conv=notrunc
# 写入位置：Sector 64（32KB）
# 关键：conv=notrunc 保证不清空已创建的 GPT 分区表

# 步骤 2: 写入 U-Boot
dd if=$BUILD/uboot/uboot.img of=$IMAGE seek=$UBOOT_START conv=notrunc,fsync
# 写入位置：Sector 24576（12MB）

# 步骤 3: 写入 Trust（ATF + OP-TEE）
dd if=$BUILD/uboot/trust.img of=$IMAGE seek=$TRUST_START conv=notrunc,fsync
# 写入位置：Sector 32768（16MB）

# 步骤 4: 写入 Boot（Kernel + DTB + Initramfs）
dd if=$BUILD/kernel/boot.img of=$IMAGE seek=$BOOT_START conv=notrunc,fsync
# 写入位置：Sector 49152（24MB）

# 步骤 5: 写入 Rootfs
dd if=${IMAGE}2 of=$IMAGE seek=$ROOTFS_START conv=notrunc,fsync
# 写入位置：Sector 376832（184MB）
# ${IMAGE}2 是之前创建的临时 ext4 文件系统
```

**关键问题：为什么不直接 mount 分区再 cp 文件？**
- **GPT 分区在镜像文件中** - 无法直接 mount 镜像中的某个分区
- **loop 设备的复杂性** - 需要 `losetup -P` 扫描分区，但 CI 环境可能无权限
- **dd 的精确性** - 可以精确控制写入位置，避免覆盖其他分区

---

### 3.3 Rootfs 分区的动态大小计算

```bash
# build_image.sh:20-22

# 1. 计算 rootfs 内容大小（单位：KB）
IMG_ROOTFS_SIZE=$(expr `du -s $DEST | awk 'END {print $1}'` + 400 * 1024)
# 参数解析：
#   - du -s $DEST: 统计 $DEST 目录的大小（KB）
#   - + 400 * 1024: 预留 400MB 空间（用于用户数据、日志等）

# 2. 计算镜像文件最小大小（单位：字节）
GPTIMG_MIN_SIZE=$(expr $IMG_ROOTFS_SIZE * 1024 + $ROOTFS_START * 512)
# 公式：rootfs内容大小 + 前面分区占用的空间

# 3. 转换为 MB 并向上取整
GPT_IMAGE_SIZE=$(expr $GPTIMG_MIN_SIZE / 1024 / 1024 + 2)
```

**示例计算**：
```bash
假设 rootfs 内容为 2GB（2097152 KB）
IMG_ROOTFS_SIZE = 2097152 + 409600 = 2506752 KB

GPTIMG_MIN_SIZE = 2506752 * 1024 + 376832 * 512
                = 2566914048 + 193019904
                = 2759933952 字节

GPT_IMAGE_SIZE = 2759933952 / 1024 / 1024 + 2
               = 2632 + 2
               = 2634 MB
```

---

## 四、镜像烧录到 eMMC 的流程

### 4.1 install_to_emmc 脚本的关键步骤

```bash
# external/install_to_emmc

# 1. 自动检测 eMMC 设备
root_uuid=$(sed -e 's/^.*root=//' -e 's/ .*$//' < /proc/cmdline)
root_partition=$(blkid | tr -d '":' | grep "${root_uuid}" | awk '{print $1}')
emmc=$(ls -d -1 /dev/mmcblk* | grep -v "$root_partition_device")
# 逻辑：
#   - 读取当前启动的 root 分区 UUID
#   - 排除当前运行的存储设备
#   - 剩下的就是目标 eMMC

# 2. 卸载所有 eMMC 分区（避免冲突）
for n in ${emmc}*; do
    if mount | grep -q "$n"; then
        umount -l "$n" >/dev/null 2>&1
    fi
done

# 3. 创建 GPT 分区表（与 build_image.sh 完全相同）
parted -s $emmc mklabel gpt
parted -s $emmc unit s mkpart uboot  ${UBOOT_START}  ${UBOOT_END}
parted -s $emmc unit s mkpart trust  ${TRUST_START}  ${TRUST_END}
parted -s $emmc unit s mkpart boot   ${BOOT_START}   ${BOOT_END}
parted -s $emmc -- unit s mkpart rootfs ${ROOTFS_START} -34s

# 4. 设置 rootfs UUID
gdisk $emmc <<EOF
x
c
4
${ROOT_UUID}
w
y
EOF

# 5. 格式化 rootfs 分区
mkfs.ext4 -F -b 4096 -E stride=2,stripe-width=1024 -L rootfs ${emmc}p4

# 6. 写入 Bootloader 和 Kernel
dd if=$bootdir/idbloader.img of=$emmc seek=$LOADER1_START conv=notrunc
dd if=$bootdir/uboot.img     of=$emmc seek=$UBOOT_START    conv=notrunc,fsync
dd if=$bootdir/trust.img     of=$emmc seek=$TRUST_START    conv=notrunc,fsync
dd if=$bootdir/boot.img      of=$emmc seek=$BOOT_START     conv=notrunc,fsync

# 7. 复制 rootfs 内容
mount ${emmc}p4 ${odir}
rsync -a -x --delete --exclude-from=$bootdir/exclude.list / ${odir}
umount $odir
```

**为什么要排除某些目录？**
```bash
# exclude.list 内容
var/log/*        # 日志文件（运行时生成）
var/cache/*      # 缓存文件
var/tmp/*        # 临时文件
boot/*           # boot 分区内容（已通过 dd 写入）
```

---

## 五、H3/H6 与 RK3399 镜像构建的对比

### 5.1 架构差异

| 项目 | H3/H6 | RK3399 |
|------|-------|--------|
| **分区表** | MBR（fdisk） | GPT（parted + gdisk） |
| **Boot 分区** | VFAT（存放 uImage + DTB） | ext4（打包成 boot.img） |
| **Bootloader 位置** | Sector 8 + Sector 16400 | Sector 64（idbloader） |
| **Bootloader 工具** | boot0 + u-boot（sunxi-tools） | boot_merger + loaderimage（rockchip） |
| **Trust 分区** | 无 | 有（存放 ATF + OP-TEE） |
| **Kernel 格式** | uImage（H3）或 Image（H6） | boot.img（kernel + ramdisk + dtb 打包） |

### 5.2 代码对比

**H3/H6 的 Bootloader 写入**（build_image.sh:110-113）:
```bash
boot0="${BUILD}/uboot/boot0_sdcard_${CHIP}.bin"
uboot="${BUILD}/uboot/u-boot-${CHIP}.bin"
dd if="${boot0}" conv=notrunc bs=1k seek=8      of="${IMAGE}"  # 8KB 偏移
dd if="${uboot}" conv=notrunc bs=1k seek=16400  of="${IMAGE}"  # 16MB 偏移
```

**RK3399 的 Bootloader 写入**（build_image.sh:62-64）:
```bash
dd if=$BUILD/uboot/idbloader.img of=$IMAGE seek=64     conv=notrunc  # 32KB
dd if=$BUILD/uboot/uboot.img     of=$IMAGE seek=24576  conv=notrunc  # 12MB
dd if=$BUILD/uboot/trust.img     of=$IMAGE seek=32768  conv=notrunc  # 16MB
```

**关键差异**：
- H3/H6 的 boot0 和 u-boot 是 **单个二进制文件**
- RK3399 的 idbloader/uboot/trust 是 **经过 rockchip 工具打包** 的镜像（带头部信息）

---

## 六、启动流程与地址映射

### 6.1 完整的启动链

```
RK3399 BootROM（芯片内固化）
    ↓
读取 Sector 64: idbloader.img
    ├─ DDR 初始化（rk3399_ddr_800MHz_v1.22.bin）
    └─ Miniloader（rk3399_miniloader_v1.19.bin）
        ↓
读取 Sector 24576: uboot.img
    └─ U-Boot（加载地址：0x00200000）
        ↓
读取 Sector 32768: trust.img
    ├─ BL31 - ARM Trusted Firmware（加载地址：0x00010000）
    └─ BL32 - OP-TEE（加载地址：0x08400000）
        ↓
读取 Sector 49152: boot.img
    ├─ Kernel Image（zImage 或 Image）
    ├─ Device Tree Blob（rk3399-orangepi.dtb）
    └─ Initramfs（initrd.img）
        ↓
挂载 Sector 376832: rootfs 分区
    └─ systemd 启动用户空间
```

### 6.2 关键内存地址映射

| 组件 | 加载地址 | 说明 | 来源 |
|------|---------|------|------|
| BL31 | 0x00010000 | ATF 运行时地址（64KB） | RK3399TRUST.ini:9 |
| BL32 | 0x08400000 | OP-TEE 地址（132MB） | RK3399TRUST.ini:13 |
| U-Boot | 0x00200000 | U-Boot 重定位后地址（2MB） | uboot/configs/*_defconfig |
| Kernel | 0x00280000 | Kernel 解压后的运行地址（2.5MB） | kernel/arch/arm64/boot/dts/rockchip/rk3399.dtsi |

**为什么这些地址不能冲突？**
- BL31 常驻内存（EL3 异常处理）
- BL32（OP-TEE）运行在 Secure World
- U-Boot 和 Kernel 都会重定位到高地址
- 错误的地址配置会导致启动时内存覆盖崩溃

---

## 七、常见问题与调试

### 7.1 镜像烧录后无法启动

**症状**: 串口无输出或卡在 "DDR init"

**可能原因**:
1. **idbloader 写入位置错误**
   ```bash
   # 检查：确认 Sector 64 处有正确的头部
   dd if=/dev/mmcblk0 bs=512 skip=64 count=1 | hexdump -C
   # 应该看到类似 "RK33" 或特定的 magic number
   ```

2. **分区表覆盖了 idbloader**
   ```bash
   # 错误示例：GPT 头部占用了前 34 个 sector
   parted -s $IMAGE unit s mkpart loader 0 100  # ❌ 错误！
   # 正确做法：idbloader 不在分区表中，直接 dd 写入
   ```

3. **dd 命令缺少 conv=notrunc**
   ```bash
   dd if=uboot.img of=$IMAGE seek=24576  # ❌ 会截断文件
   dd if=uboot.img of=$IMAGE seek=24576 conv=notrunc  # ✅ 正确
   ```

---

### 7.2 rootfs 挂载失败

**症状**: Kernel panic - not syncing: VFS: Unable to mount root fs

**可能原因**:
1. **UUID 不匹配**
   ```bash
   # 检查分区 UUID
   blkid /dev/mmcblk0p4
   # 应该输出：UUID="614e0000-0000-4b53-8000-1d28000054a9"

   # 检查 /etc/fstab
   cat /mnt/rootfs/etc/fstab
   # 应该包含：UUID=614e0000-0000-4b53-8000-1d28000054a9  /  ext4  ...
   ```

2. **分区起始位置错误**
   ```bash
   # 检查分区布局
   parted /dev/mmcblk0 unit s print
   # 确认 rootfs 起始于 Sector 376832
   ```

---

### 7.3 eMMC 空间不足

**症状**: `No space left on device` 或镜像构建失败

**解决方法**:
```bash
# 调整 rootfs 预留空间（build_image.sh:20）
IMG_ROOTFS_SIZE=$(expr `du -s $DEST | awk 'END {print $1}'` + 800 * 1024)
# 从 400MB 增加到 800MB

# 或者减少 rootfs 内容
apt-get clean  # 清理 apt 缓存
rm -rf /var/log/*  # 清理日志
```

---

## 八、总结

### 8.1 核心知识点

1. **Sector 64 的硬件约束** - BootROM 硬编码，无法更改
2. **GPT vs MBR** - RK3399 使用 GPT 支持大容量和安全启动
3. **dd 的 conv=notrunc** - 镜像组装的关键参数
4. **固定 UUID** - 保证跨设备的 rootfs 挂载稳定性
5. **分区地址的计算** - Sector × 512 = 字节偏移

### 8.2 学习建议

- **实践验证**: 使用 `hexdump` 查看镜像前 1MB 的内容
- **对比代码**: 比较 `build_image.sh` 和 `install_to_emmc` 的差异
- **移植参考**: 如果需要适配 RK3588，重点关注 Sector 地址是否变化
- **调试工具**: 串口输出 + `parted print` + `blkid`

### 8.3 与其他平台的差异

| 知识点 | 通用性 | RK3399 特有 |
|--------|-------|------------|
| Kernel 编译 | ✅ 通用 | - |
| Rootfs 构建 | ✅ 通用 | - |
| **分区布局** | ❌ 平台特定 | ✅ Sector 64、GPT |
| **Bootloader 打包** | ❌ 平台特定 | ✅ boot_merger/trust_merger |
| **dd 镜像组装** | ✅ 大部分通用 | ⚠️ 地址不同 |

---

## 参考文件

- `scripts/lib/build_image.sh` - 镜像构建主逻辑
- `external/install_to_emmc` - eMMC 烧录脚本
- `uboot/RK3399_Loader构建流程详解.md` - Loader 打包流程
- `uboot/固件打包原理深度解析.md` - 头部格式和签名
