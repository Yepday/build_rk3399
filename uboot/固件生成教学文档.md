# U-Boot 固件生成完整教学文档

## 目录
1. [概述](#概述)
2. [固件生成流程](#固件生成流程)
3. [核心固件生成函数详解](#核心固件生成函数详解)
4. [使用示例](#使用示例)
5. [配置文件说明](#配置文件说明)
6. [故障排查](#故障排查)

---

## 概述

### 什么是 make.sh？
`make.sh` 是 Rockchip U-Boot 的构建脚本，负责：
- 编译 U-Boot 源代码
- 生成三种核心固件镜像：**uboot.img**、**loader.bin**、**trust.img**
- 支持多种 Rockchip SoC 平台（RK3399、RK3288、RK3308 等）

### 生成的固件文件
| 固件名称 | 说明 | 架构支持 |
|---------|------|---------|
| `uboot.img` | U-Boot 主镜像 | ARM32/ARM64 |
| `*_loader_*.bin` | 预加载器（BootROM 加载） | ARM32/ARM64 |
| `trust.img` | 安全固件（ATF/OP-TEE） | ARM32/ARM64 |
| `idbloader.img` | SPL+DDR 初始化镜像 | ARM32/ARM64 |
| `u-boot.itb` | FIT 格式镜像（可选） | ARM64 |

---

## 固件生成流程

### 主流程（脚本第 812-821 行）
```bash
prepare                      # 1. 准备工作
select_toolchain            # 2. 选择工具链
select_chip_info            # 3. 选择芯片信息
fixup_platform_configure    # 4. 修正平台配置
sub_commands                # 5. 处理子命令
make CROSS_COMPILE=${TOOLCHAIN_GCC} all --jobs=${JOB} ${OUTOPT}  # 6. 编译 U-Boot
pack_uboot_image            # 7. 打包 uboot.img
pack_loader_image           # 8. 打包 loader.bin
pack_trust_image            # 9. 打包 trust.img
finish                      # 10. 完成提示
```

### 流程图
```
┌─────────────────────┐
│  1. prepare()       │  解析参数、检查 rkbin 路径
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 2. select_toolchain │  选择 ARM32/ARM64 工具链
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 3. select_chip_info │  识别芯片型号（RK3399/RK3288...）
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 4. fixup_platform   │  设置 RSA/SHA、镜像大小
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 5. sub_commands()   │  处理 loader/trust/uboot 子命令
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 6. make all         │  编译生成 u-boot.bin
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 7. pack_uboot_image │  u-boot.bin → uboot.img
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 8. pack_loader_image│  MINIALL.ini → *_loader_*.bin
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 9. pack_trust_image │  TRUST.ini → trust.img
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 10. finish()        │  显示完成信息
└─────────────────────┘
```

---

## 核心固件生成函数详解

### 1. pack_uboot_image() - 生成 uboot.img（第 528-565 行）

**功能**：将编译后的 `u-boot.bin` 打包成可引导的 `uboot.img`

**关键代码**：
```bash
pack_uboot_image()
{
    # 1. 检查 u-boot.bin 大小是否超限
    UBOOT_KB=`ls -l u-boot.bin | awk '{print $5}'`
    if [ $UBOOT_KB -gt $UBOOT_MAX_KB ]; then
        echo "ERROR: u-boot.bin 太大！"
        exit 1
    fi

    # 2. 获取加载地址（通常是 0x00200000）
    UBOOT_LOAD_ADDR=`sed -n "/CONFIG_SYS_TEXT_BASE=/s/CONFIG_SYS_TEXT_BASE=//p" \
                      ${OUTDIR}/include/autoconf.mk|tr -d '\r'`

    # 3. 使用 loaderimage 工具打包
    ${RKTOOLS}/loaderimage --pack --uboot ${OUTDIR}/u-boot.bin uboot.img \
                           ${UBOOT_LOAD_ADDR} ${PLATFORM_UBOOT_IMG_SIZE}

    # 4. 删除中间文件
    rm ${OUTDIR}/u-boot.img ${OUTDIR}/u-boot-dtb.img
}
```

**输入文件**：
- `u-boot.bin` - make 编译生成的原始二进制文件

**输出文件**：
- `uboot.img` - 添加了 Rockchip 头部的可引导镜像

**工具**：
- `loaderimage` - Rockchip 官方打包工具（位于 `../rkbin/tools/`）

---

### 2. pack_loader_image() - 生成 loader.bin（第 654-696 行）

**功能**：根据 INI 配置文件打包预加载器（包含 DDR 初始化、miniloader）

**关键代码**：
```bash
pack_loader_image()
{
    local mode=$1
    local ini=${RKBIN}/RKBOOT/${RKCHIP_LOADER}MINIALL.ini

    # 1. 检查 INI 文件是否存在
    if [ ! -f $ini ]; then
        echo "pack loader failed! Can't find: $ini"
        return
    fi

    # 2. 清理旧的 loader 文件
    ls *_loader_*.bin >/dev/null 2>&1 && rm *_loader_*.bin
    cd ${RKBIN}

    # 3. 使用 boot_merger 打包
    if [ "${mode}" = 'all' ]; then
        # 打包所有支持的 loader
        files=`ls ${RKBIN}/RKBOOT/${RKCHIP_LOADER}MINIALL*.ini`
        for ini in $files; do
            ${RKTOOLS}/boot_merger ${BIN_PATH_FIXUP} $ini
        done
    else
        # 打包默认 loader
        ${RKTOOLS}/boot_merger ${BIN_PATH_FIXUP} $ini
    fi

    # 4. 生成 idbloader.img（用于 SD 卡启动）
    local flashData=`grep FlashData= $ini | cut -f 2 -d "="`
    local flashBoot=`grep FlashBoot= $ini | cut -f 2 -d "="`
    ${RKTOOLS}/mkimage -n ${RKCHIP} -T rksd -d ${RKBIN}/${flashData} idbloader.img
    cat ${RKBIN}/${flashBoot} >> idbloader.img
}
```

**输入文件**：
- `RKBOOT/${RKCHIP}MINIALL.ini` - Loader 配置文件
- DDR 初始化文件（如 `rk33/rk3399_ddr_800MHz_v1.bin`）
- Miniloader 文件（如 `rk33/rk3399_miniloader_v1.bin`）

**输出文件**：
- `rk3399_loader_vX.XX.bin` - 完整的 loader 镜像
- `idbloader.img` - SD 卡引导镜像

**工具**：
- `boot_merger` - 合并 DDR 和 miniloader
- `mkimage` - 生成 Rockchip SD 卡镜像

**INI 配置示例**（RK3399MINIALL.ini）：
```ini
[CHIP_NAME]
NAME=RK330C
[VERSION]
MAJOR=2
MINOR=50
[CODE471_OPTION]
NUM=1
Path1=bin/rk33/rk3399_ddr_800MHz_v1.25.bin
Sleep=1
[CODE472_OPTION]
NUM=1
Path1=bin/rk33/rk3399_usbplug_v1.25.bin
[LOADER_OPTION]
NUM=2
LOADER1=FlashData
LOADER2=FlashBoot
FlashData=bin/rk33/rk3399_ddr_800MHz_v1.25.bin
FlashBoot=bin/rk33/rk3399_miniloader_v1.25.bin
[OUTPUT]
PATH=rk3399_loader_v1.25.126.bin
```

---

### 3. pack_trust_image() - 生成 trust.img（第 763-818 行）

**功能**：打包安全固件（ATF BL31 + OP-TEE）

**关键代码**：
```bash
pack_trust_image()
{
    local mode=$1

    # 1. 删除旧的 trust 镜像
    ls trust*.img >/dev/null && rm trust*.img

    # 2. 根据架构选择打包方式
    if grep -Eq ''^CONFIG_ARM64=y'|'^CONFIG_ARM64_BOOT_AARCH32=y'' ${OUTDIR}/.config ; then
        # ARM64 使用 trust_merger
        ini=${RKBIN}/RKTRUST/${RKCHIP_TRUST}TRUST.ini

        if [ "${mode}" = 'all' ]; then
            # 打包所有配置
            files=`ls ${RKBIN}/RKTRUST/${RKCHIP_TRUST}TRUST*.ini`
            for ini in $files; do
                __pack_64bit_trust_image ${ini}
            done
        else
            __pack_64bit_trust_image ${ini}
        fi
    else
        # ARM32 使用 loaderimage
        ini=${RKBIN}/RKTRUST/${RKCHIP_TRUST}TOS.ini

        if [ "${mode}" = 'all' ]; then
            files=`ls ${RKBIN}/RKTRUST/${RKCHIP_TRUST}TOS*.ini`
            for ini in $files; do
                __pack_32bit_trust_image ${ini}
            done
        else
            __pack_32bit_trust_image ${ini}
        fi
    fi
}
```

**ARM64 打包函数**（第 745-761 行）：
```bash
__pack_64bit_trust_image()
{
    local ini=$1

    cd ${RKBIN}
    # 使用 trust_merger 合并 BL31 + BL32(OP-TEE) + BL33
    ${RKTOOLS}/trust_merger \
        ${PLATFORM_SHA} \           # SHA 算法（默认或 SHA256）
        ${PLATFORM_RSA} \           # RSA 签名（PKCS1 v2.1）
        ${PLATFORM_TRUST_IMG_SIZE} \  # 镜像大小限制
        ${BIN_PATH_FIXUP} \
        ${PACK_IGNORE_BL32} \       # 是否忽略 BL32（OP-TEE）
        ${ini}

    cd - && mv ${RKBIN}/trust*.img ./
}
```

**ARM32 打包函数**（第 698-743 行）：
```bash
__pack_32bit_trust_image()
{
    local ini=$1

    # 1. 从 INI 读取 TOS 路径
    TOS=`sed -n "/TOS=/s/TOS=//p" ${ini} |tr -d '\r'`
    TOS_TA=`sed -n "/TOSTA=/s/TOSTA=//p" ${ini} |tr -d '\r'`

    # 2. 计算加载地址（DRAM_BASE + 132M）
    DARM_BASE=`sed -n "/CONFIG_SYS_SDRAM_BASE=/s/CONFIG_SYS_SDRAM_BASE=//p" \
               ${OUTDIR}/include/autoconf.mk|tr -d '\r'`
    TEE_LOAD_ADDR=$((DARM_BASE+0x8400000))
    TEE_LOAD_ADDR=$(echo "obase=16;${TEE_LOAD_ADDR}"|bc)

    # 3. 打包 TOS 镜像
    if [ $TOS_TA ]; then
        ${RKTOOLS}/loaderimage --pack --trustos ${RKBIN}/${TOS_TA} \
                               ${TEE_OUTPUT} ${TEE_LOAD_ADDR} ${PLATFORM_TRUST_IMG_SIZE}
    fi
}
```

**输入文件**：
- **ARM64**：
  - `RKTRUST/${RKCHIP}TRUST.ini` - Trust 配置文件
  - BL31 文件（ARM Trusted Firmware）
  - BL32 文件（OP-TEE，可选）

- **ARM32**：
  - `RKTRUST/${RKCHIP}TOS.ini` - TOS 配置文件
  - OP-TEE 二进制文件

**输出文件**：
- `trust.img` - 安全固件镜像

**INI 配置示例**（RK3399TRUST.ini）：
```ini
[BL30_OPTION]
SEC=0
PATH=bin/rk33/rk3399_bl30_v2.22.elf
ADDR=0x00080000
[BL31_OPTION]
SEC=1
PATH=bin/rk33/rk3399_bl31_v1.35.elf
ADDR=0x00010000
[BL32_OPTION]
SEC=1
PATH=bin/rk33/rk3399_bl32_v2.01.bin
ADDR=0x08400000
[BL33_OPTION]
SEC=0
[OUTPUT]
PATH=trust.img
```

---

### 4. pack_spl_loader_image() - 生成 SPL Loader（第 608-652 行）

**功能**：打包 TPL + SPL 合成的 loader（用于某些平台）

**关键代码**：
```bash
pack_spl_loader_image()
{
    local mode=$1
    local ini=${RKBIN}/RKBOOT/${RKCHIP_LOADER}MINIALL.ini

    # 1. 拷贝 SPL 和 TPL 到临时目录
    mkdir ${RKBIN}/.temp
    cp ${OUTDIR}/spl/u-boot-spl.bin ${RKBIN}/.temp/
    cp ${OUTDIR}/tpl/u-boot-tpl.bin ${RKBIN}/.temp/

    # 2. 修改 TPL 头部（添加芯片标识）
    if [ "$mode" = 'spl' ]; then
        header=`sed -n '/NAME=/s/NAME=//p' ${ini}`
        dd if=${RKBIN}/.temp/u-boot-tpl.bin of=${RKBIN}/.temp/tpl.bin bs=1 skip=4
        sed -i "1s/^/${header:0:4}/" ${RKBIN}/.temp/tpl.bin
        sed -i "s/FlashData=.*$/FlashData=.\/.temp\/tpl.bin/" ${temp_ini}
    fi

    # 3. 使用 boot_merger 打包
    sed -i "s/FlashBoot=.*$/FlashBoot=.\/.temp\/u-boot-spl.bin/" ${temp_ini}
    ${RKTOOLS}/boot_merger ${BIN_PATH_FIXUP} ${temp_ini}

    # 4. 清理临时文件
    rm ${RKBIN}/.temp -rf
}
```

**适用平台**：RK3308、RK3326（需要 SPL 初始化内存）

---

### 5. pack_uboot_itb_image() - 生成 FIT 镜像（第 567-606 行）

**功能**：将 U-Boot + ATF + DTB 打包成 FIT 格式镜像（用于启动优化）

**关键代码**：
```bash
pack_uboot_itb_image()
{
    # ARM64 平台
    if grep -Eq ''^CONFIG_ARM64=y'|'^CONFIG_ARM64_BOOT_AARCH32=y'' ${OUTDIR}/.config ; then
        ini=${RKBIN}/RKTRUST/${RKCHIP_TRUST}TRUST.ini

        # 1. 提取 BL31 文件
        bl31=`sed -n '/_bl31_/s/PATH=//p' ${ini} |tr -d '\r'`
        cp ${RKBIN}/${bl31} bl31.elf

        # 2. 编译生成 u-boot.itb
        make CROSS_COMPILE=${TOOLCHAIN_GCC} u-boot.itb
    else
        # ARM32 平台（提取 TEE）
        TOS=`sed -n "/TOS=/s/TOS=//p" ${ini} |tr -d '\r'`
        cp ${RKBIN}/${TOS} tee.bin
        make CROSS_COMPILE=${TOOLCHAIN_GCC} u-boot.itb
    fi
}
```

**FIT 镜像优势**：
- 单文件包含所有组件（u-boot + dtb + atf）
- 支持镜像签名和验证
- 启动速度更快

---

## 使用示例

### 示例 1：完整编译（推荐）
```bash
# 编译 RK3399 开发板
./make.sh evb-rk3399

# 指定输出目录
./make.sh evb-rk3399 O=rockdev

# 生成文件：
# - uboot.img
# - rk3399_loader_v1.25.126.bin
# - trust.img
```

### 示例 2：仅重新打包固件
```bash
# 已编译过，仅重新打包 uboot
./make.sh uboot

# 仅重新打包 loader
./make.sh loader

# 仅重新打包 trust
./make.sh trust

# 打包所有支持的 trust 版本
./make.sh trust-all
```

### 示例 3：使用自定义配置文件
```bash
# 使用指定的 INI 文件打包 loader
FILE=../rkbin/RKBOOT/RK3399MINIALL_SPINOR.ini ./make.sh loader

# 使用指定的 INI 文件打包 trust
FILE=../rkbin/RKTRUST/RK3399TRUST_SELFTEST.ini ./make.sh trust
```

### 示例 4：生成 FIT 镜像
```bash
./make.sh itb

# 生成文件：u-boot.itb
```

---

## 配置文件说明

### 1. 芯片识别逻辑（select_chip_info 函数）

脚本通过读取 `.config` 文件自动识别芯片：

```bash
# 识别规则（正则表达式）
chip_reg='^CONFIG_ROCKCHIP_[R,P][X,V,K][0-9ESX]{1,5}'

# 示例匹配：
# CONFIG_ROCKCHIP_RK3399=y  → RKCHIP=RK3399
# CONFIG_ROCKCHIP_RK3288=y  → RKCHIP=RK3288
# CONFIG_ROCKCHIP_PX30=y    → RKCHIP=PX30
```

### 2. 平台特殊配置（fixup_platform_configure 函数）

不同平台有不同的安全配置和镜像大小：

| 平台 | RSA 算法 | SHA 算法 | U-Boot 大小 | Trust 大小 |
|------|---------|---------|------------|-----------|
| RK3399 | 默认 | 默认 | 1024KB | 默认 |
| RK3308 | PKCS1 v2.1 | 默认 | 512KB/1024KB | 512KB/1024KB |
| PX30/RK3326 | PKCS1 v2.1 | 默认 | 默认 | 默认 |
| RK3368 | 默认 | Big Endian | 默认 | 默认 |

**代码实现**：
```bash
# RK3308/PX30 使用 RSA-PKCS1 V2.1
if [ $RKCHIP = "PX30" -o $RKCHIP = "RK3308" ]; then
    PLATFORM_RSA="--rsa 3"
fi

# RK3368 使用大端 SHA256
if [ $RKCHIP = "RK3368" ]; then
    PLATFORM_SHA="--sha 2"
fi

# RK3308 镜像大小限制
if [ $RKCHIP = "RK3308" ]; then
    PLATFORM_UBOOT_IMG_SIZE="--size 1024 2"
    PLATFORM_TRUST_IMG_SIZE="--size 1024 2"
fi
```

### 3. 工具链选择（select_toolchain 函数）

根据 `.config` 自动选择 ARM32 或 ARM64 工具链：

```bash
if grep -q '^CONFIG_ARM64=y' ${OUTDIR}/.config ; then
    # ARM64 工具链
    TOOLCHAIN_GCC=aarch64-linux-gnu-
    TOOLCHAIN_OBJDUMP=aarch64-linux-gnu-objdump
else
    # ARM32 工具链
    TOOLCHAIN_GCC=arm-linux-gnueabihf-
    TOOLCHAIN_OBJDUMP=arm-linux-gnueabihf-objdump
fi
```

**可修改路径**（第 40-42 行）：
```bash
TOOLCHAIN_ARM32=../prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1/bin
TOOLCHAIN_ARM64=../toolchain/gcc-linaro-6.3.1-aarch64/bin/
```

---

## 故障排查

### 问题 1：找不到 rkbin 仓库
**错误信息**：
```
Can't find '../rkbin/' repository
```

**解决方法**：
```bash
# 下载 rkbin 仓库到上级目录
cd ..
git clone https://github.com/rockchip-linux/rkbin.git
cd -
```

### 问题 2：找不到工具链
**错误信息**：
```
Can't find toolchain: ../toolchain/gcc-linaro-6.3.1
```

**解决方法**：
```bash
# 方法1：下载官方工具链
wget https://releases.linaro.org/components/toolchain/binaries/6.3-2017.05/aarch64-linux-gnu/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.xz
tar -xf gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.xz -C ../toolchain/

# 方法2：使用系统工具链（修改 make.sh 第 42 行）
TOOLCHAIN_ARM64=/usr/bin/
```

### 问题 3：u-boot.bin 太大
**错误信息**：
```
ERROR: pack uboot failed! u-boot.bin actual: 1200000 bytes, max limit: 1046528 bytes
```

**解决方法**：
```bash
# 1. 禁用不必要的功能（修改 defconfig）
CONFIG_CMD_BMP=n          # 禁用 BMP 图片支持
CONFIG_VIDEO=n            # 禁用视频输出
CONFIG_USB_STORAGE=n      # 禁用 USB 存储

# 2. 启用编译器优化
CONFIG_CC_OPTIMIZE_FOR_SIZE=y

# 3. 强制修改大小限制（仅测试用）
PLATFORM_UBOOT_IMG_SIZE="--size 2048 2"
```

### 问题 4：找不到 INI 配置文件
**错误信息**：
```
pack loader failed! Can't find: ../rkbin/RKBOOT/RK3399MINIALL.ini
```

**解决方法**：
```bash
# 1. 检查 rkbin 版本
cd ../rkbin && git log --oneline -1

# 2. 查看可用的 INI 文件
ls RKBOOT/RK3399*.ini
ls RKTRUST/RK3399*.ini

# 3. 更新 rkbin 到最新版本
git pull origin master
```

### 问题 5：trust_merger 工具权限错误
**错误信息**：
```
/bin/bash: ../rkbin/tools/trust_merger: Permission denied
```

**解决方法**：
```bash
# 添加执行权限
chmod +x ../rkbin/tools/*
```

---

## 附录：关键工具说明

### A. loaderimage
**位置**：`../rkbin/tools/loaderimage`

**功能**：
- 打包 u-boot.bin → uboot.img
- 打包 OP-TEE → trust.img（ARM32）

**用法**：
```bash
loaderimage --pack --uboot u-boot.bin uboot.img 0x00200000
loaderimage --pack --trustos tee.bin trust.img 0x68400000 --size 1024 2
```

### B. boot_merger
**位置**：`../rkbin/tools/boot_merger`

**功能**：
- 合并 DDR 初始化代码 + Miniloader
- 生成 `*_loader_*.bin`

**用法**：
```bash
boot_merger --replace tools/rk_tools/ ./ RKBOOT/RK3399MINIALL.ini
```

### C. trust_merger
**位置**：`../rkbin/tools/trust_merger`

**功能**：
- 合并 BL31 + BL32（OP-TEE）+ BL33
- 生成 trust.img（ARM64）

**用法**：
```bash
trust_merger --rsa 3 --sha 2 --size 1024 2 RKTRUST/RK3399TRUST.ini
```

### D. mkimage
**位置**：`../rkbin/tools/mkimage`

**功能**：
- 生成 Rockchip SD 卡启动镜像
- 添加 Rockchip 头部信息

**用法**：
```bash
mkimage -n rk3399 -T rksd -d ddr.bin idbloader.img
```

---

## 总结

本文档详细讲解了 Rockchip U-Boot 固件生成的全流程，核心要点：

1. **三大固件**：uboot.img、loader.bin、trust.img
2. **核心函数**：
   - `pack_uboot_image` - 打包 U-Boot
   - `pack_loader_image` - 打包 Loader
   - `pack_trust_image` - 打包安全固件
3. **配置文件**：INI 文件控制组件路径和版本
4. **工具链**：根据架构自动选择 ARM32/ARM64

**快速开始**：
```bash
# 一键编译
./make.sh evb-rk3399

# 输出固件位于当前目录：
# - uboot.img
# - rk3399_loader_v1.xx.bin
# - trust.img
```

---

**文档版本**：v1.0
**适用平台**：Rockchip RK3399/RK3288/RK3308/PX30 等
**最后更新**：2025-12-07
