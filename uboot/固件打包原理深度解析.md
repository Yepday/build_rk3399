# Rockchip 固件打包原理深度解析

## 目录
1. [为什么需要打包？](#为什么需要打包)
2. [Rockchip 启动流程](#rockchip-启动流程)
3. [固件镜像格式详解](#固件镜像格式详解)
4. [打包工具原理](#打包工具原理)
5. [加密与签名机制](#加密与签名机制)
6. [实战：手动解包与打包](#实战手动解包与打包)

---

## 为什么需要打包？

### 原始二进制文件的问题

编译生成的 `u-boot.bin` 只是纯粹的二进制代码，**无法直接被 Rockchip BootROM 识别和加载**。

```
编译输出 u-boot.bin:
┌─────────────────────────────┐
│ ARM 汇编指令（二进制码）      │
│ 0xE59FF014 (ldr pc, ...)    │
│ 0xE59FF014 ...              │
│ ...                         │
│ (无任何头部信息)              │
└─────────────────────────────┘
     ↓ BootROM 无法识别！
```

### BootROM 的要求

Rockchip BootROM（芯片固化的引导代码）在加载固件时需要：

1. **魔数（Magic Number）** - 识别这是 Rockchip 固件
2. **芯片型号标识** - 确认固件与芯片匹配
3. **加载地址** - 指示代码应加载到内存的哪个位置
4. **代码长度** - 知道需要读取多少字节
5. **校验和/签名** - 验证固件完整性和合法性
6. **时间戳/版本** - 固件管理信息

**打包的本质**：在原始二进制代码前后添加 BootROM 需要的头部和尾部信息。

```
打包后 uboot.img:
┌─────────────────────────────┐
│ Rockchip 头部 (512 字节)     │  ← loaderimage 添加
│ - 魔数: 0x0FF0AA55          │
│ - 芯片: RK3399              │
│ - 加载地址: 0x00200000      │
│ - 代码长度: 1024576 字节    │
│ - 校验和: 0xABCD1234        │
├─────────────────────────────┤
│ u-boot.bin 原始代码          │  ← 原始二进制
│ (编译生成的代码)              │
├─────────────────────────────┤
│ 填充对齐 (4KB 对齐)          │  ← 对齐到扇区边界
└─────────────────────────────┘
     ↓ BootROM 可以识别并加载！
```

---

## Rockchip 启动流程

### 完整启动链

```
上电复位
  ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 1: BootROM (芯片内部 ROM)                                │
│ - 固化在芯片中，无法修改                                       │
│ - 从 eMMC/SD/SPI/USB 查找 loader                             │
│ - 验证 loader 头部魔数                                        │
│ - 加载 DDR 初始化代码到 SRAM (256KB)                          │
└─────────────────────────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 2: DDR Init (bin/rk33/rk3399_ddr_800MHz_v1.bin)         │
│ - 运行在 SRAM 中（256KB 限制）                                │
│ - 初始化 DDR 控制器和内存                                      │
│ - 配置内存时序、频率（800MHz/1600MHz）                        │
│ - 代码大小：约 100-150 KB（能塞进 SRAM）                      │
│ - 内存初始化完成后返回 BootROM                                │
└─────────────────────────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 3: Miniloader (bin/rk33/rk3399_miniloader_v1.bin)       │
│ - 被 BootROM 加载到 DDR                                       │
│ - 初始化存储设备（eMMC/SD/SPI）                               │
│ - 加载 U-Boot (uboot.img) 到 DDR                             │
│ - 加载 Trust (trust.img) 到 DDR                              │
│ - 跳转到 Trust 执行                                           │
└─────────────────────────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 4: Trust / ATF BL31 (ARM Trusted Firmware)              │
│ - 初始化安全环境（TrustZone）                                 │
│ - 加载 OP-TEE (可选)                                          │
│ - 设置异常向量表                                              │
│ - 配置 GIC（中断控制器）                                       │
│ - 跳转到 U-Boot                                               │
└─────────────────────────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 5: U-Boot (uboot.img)                                   │
│ - 初始化外设（USB/网络/显示）                                  │
│ - 加载 Linux 内核                                             │
│ - 传递设备树 (DTB)                                            │
│ - 跳转到内核                                                  │
└─────────────────────────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 6: Linux Kernel                                         │
│ - 启动操作系统                                                │
└─────────────────────────────────────────────────────────────┘
```

### 三大固件在启动流程中的位置

| 固件 | 加载者 | 加载到 | 功能 |
|------|-------|--------|------|
| **loader.bin** | BootROM | SRAM → DDR | DDR 初始化 + 存储初始化 |
| **trust.img** | Miniloader | DDR | 安全环境初始化（ATF + TEE） |
| **uboot.img** | Miniloader | DDR | 系统引导和内核加载 |

---

### 代码大小对比（SRAM 空间限制）

**常见疑问**：为什么 DDR 初始化代码能塞进 SRAM，而完整的 eMMC 驱动不行？

#### 各组件代码大小

```
RK3399 启动阶段的代码大小：
┌────────────────────────────────────────────┐
│ BootROM (芯片内 ROM)                        │
│ ├─ 大小：32-64 KB                          │
│ ├─ 功能：基础引导逻辑                       │
│ └─ 特点：固化在芯片中，无法修改             │
├────────────────────────────────────────────┤
│ DDR Init (rk3399_ddr_800MHz_v1.25.bin)     │
│ ├─ 大小：100-150 KB ✅ 能放进 SRAM          │
│ ├─ 功能：DDR 控制器初始化                   │
│ └─ 运行环境：256 KB SRAM                   │
├────────────────────────────────────────────┤
│ Miniloader (rk3399_miniloader_v1.25.bin)   │
│ ├─ 大小：200-300 KB ❌ SRAM 装不下          │
│ ├─ 功能：完整 eMMC 驱动 + 烧录协议          │
│ └─ 运行环境：DDR (初始化后)                 │
└────────────────────────────────────────────┘

SRAM 空间分配（256 KB 总共）：
├─ DDR Init 代码：      ~120 KB
├─ BootROM 栈空间：      ~32 KB
├─ 临时数据缓冲区：      ~64 KB
├─ DDR 训练数据：        ~32 KB
└─ 剩余可用：             ~8 KB

如果要放完整 eMMC 驱动（200-300 KB）：
  SRAM 不够！溢出！系统崩溃！
```

#### 为什么 DDR 初始化代码可以很小？

**1. 功能单一**

```c
// DDR Init 的核心任务（简化）
void ddr_init() {
    // 1. 配置 DDR 控制器寄存器（约 100 行）
    writel(DDR_TIMING_0, 0xFF780000);
    writel(DDR_TIMING_1, 0xFF780004);
    writel(DDR_TIMING_2, 0xFF780008);
    // ... 总共约 50-100 个寄存器

    // 2. 训练 DDR 时序（约 200 行）
    ddr_phy_training();

    // 3. 测试内存（约 50 行）
    memory_test();

    // 完成！返回 BootROM
}

总代码量：约 500-1000 行 C 代码 + 汇编
编译后大小：100-150 KB
```

对比：

```c
// 完整 eMMC 驱动需要的功能
struct emmc_driver {
    // 1. 基础协议支持（约 1000 行）
    int (*send_cmd)(int cmd, uint32_t arg);
    int (*read_block)(uint32_t addr, void* buf);
    int (*write_block)(uint32_t addr, const void* buf);

    // 2. 高速模式支持（约 800 行）
    int (*switch_to_hs200)(void);
    int (*switch_to_hs400)(void);
    int (*execute_tuning)(void);

    // 3. DMA 支持（约 500 行）
    int (*setup_dma)(void);
    int (*dma_read)(uint32_t addr, void* buf, size_t len);
    int (*dma_write)(uint32_t addr, const void* buf, size_t len);

    // 4. 分区管理（约 400 行）
    int (*switch_partition)(int partition);
    int (*read_ext_csd)(uint8_t* ext_csd);

    // 5. 坏块管理（约 300 行）
    int (*mark_bad_block)(uint32_t block);
    int (*remap_block)(uint32_t bad, uint32_t good);

    // 6. Rockusb 烧录协议（约 2000 行）
    int (*rockusb_init)(void);
    int (*rockusb_write_image)(const char* partition, void* data);

    // 7. 文件系统支持（约 1000 行）
    int (*read_file)(const char* path, void* buf);
};

总代码量：约 6000-8000 行 C 代码
编译后大小：200-300 KB ❌ SRAM 装不下！
```

**2. 无需复杂状态机**

```
DDR Init：
  线性流程：配置 → 训练 → 测试 → 完成
  状态数：~5 个状态

eMMC 完整驱动：
  需要处理：
  ├─ 命令队列管理（20+ 状态）
  ├─ 异步 I/O（10+ 状态）
  ├─ 错误重试（15+ 状态）
  ├─ 电源管理（8+ 状态）
  └─ 烧录协议（50+ 状态）
  状态数：~100 个状态
```

**3. 无需协议栈**

```
DDR Init：
  直接操作硬件寄存器
  ├─ 无需协议层
  └─ 无需错误处理层

eMMC 驱动：
  完整协议栈
  ├─ 应用层（文件系统）        ~500 行
  ├─ 传输层（DMA/PIO）          ~400 行
  ├─ 协议层（CMD/ACMD）         ~600 行
  ├─ 物理层（时钟/电压控制）    ~300 行
  └─ 总计：                    ~1800 行
```

#### 实际文件大小对比

让我们看看真实的固件文件大小：

```bash
# RK3399 固件实际大小
$ ls -lh ../rkbin/bin/rk33/

-rw-r--r-- 1 user user  98K  rk3399_ddr_666MHz_v1.25.bin
-rw-r--r-- 1 user user 112K  rk3399_ddr_800MHz_v1.25.bin
-rw-r--r-- 1 user user 128K  rk3399_ddr_933MHz_v1.25.bin
                       ^^^^  DDR Init：100-130 KB ✅ 能放进 256KB SRAM

-rw-r--r-- 1 user user 245K  rk3399_miniloader_v1.25.bin
                       ^^^^  Miniloader：245 KB ❌ SRAM 装不下

-rw-r--r-- 1 user user  45K  rk3399_bl31_v1.35.elf
-rw-r--r-- 1 user user 1.2M  rk3399_bl32_v2.01.bin (OP-TEE)
```

#### 为什么不把 Miniloader 也做小一点？

**无法压缩的原因**：

1. **Rockusb 协议代码占大头**
   ```
   Miniloader 代码分布：
   ├─ eMMC 基础驱动：       60 KB
   ├─ eMMC 高速模式：       40 KB
   ├─ Rockusb 烧录协议：   100 KB  ← 占 40%！
   ├─ USB 协议栈：          30 KB
   └─ 其他（调试/错误处理）：15 KB
   总计：                  245 KB
   ```

2. **需要支持固件烧录**
   - 如果不支持烧录，Miniloader 可以压缩到 ~100 KB
   - 但那样就无法通过 USB 刷机了！

3. **需要完整的错误处理**
   ```c
   // Miniloader 需要处理各种异常
   if (emmc_read_failed()) {
       retry_with_lower_speed();
       if (still_failed()) {
           switch_to_different_partition();
           if (still_failed()) {
               fallback_to_usb_boot();  // 进入烧录模式
           }
       }
   }
   ```

#### DDR 初始化代码为何能如此精简？

**核心原因：一次性任务**

```c
// DDR Init 的生命周期
void ddr_init_lifecycle() {
    // 1. 被 BootROM 加载到 SRAM
    // 2. 执行初始化
    // 3. 返回 BootROM
    // 4. 被丢弃！内存被 Miniloader 覆盖
}

特点：
✅ 只运行一次
✅ 不需要保持状态
✅ 不需要错误恢复（失败就重启）
✅ 不需要支持多种内存类型（一个 bin 对应一种频率）
```

对比：

```c
// Miniloader 的生命周期
void miniloader_lifecycle() {
    // 1. 被 BootROM 加载到 DDR
    // 2. 初始化 eMMC
    // 3. 加载 U-Boot 和 Trust
    // 4. 等待... 可能需要进入烧录模式
    // 5. 处理 USB 命令（可能运行几分钟）
    // 6. 写入固件到 eMMC
    // 7. 重启
}

特点：
❌ 可能运行很长时间（烧录时）
❌ 需要保持状态
❌ 需要完整的错误恢复
❌ 需要支持多种存储介质（eMMC/SD/SPI）
```

#### 内存布局对比

```
SRAM (256 KB) - DDR Init 阶段：
┌──────────────────────────────┐ 0xFF8C0000
│ DDR Init 代码段               │ 120 KB
├──────────────────────────────┤
│ DDR Init 数据段               │  20 KB
├──────────────────────────────┤
│ 栈空间                        │  32 KB
├──────────────────────────────┤
│ DDR 训练临时缓冲区            │  64 KB
├──────────────────────────────┤
│ BootROM 保留区                │  20 KB
└──────────────────────────────┘ 0xFF900000
总计：256 KB  ✅ 刚好够用！

DDR (2GB) - Miniloader 阶段：
┌──────────────────────────────┐ 0x00000000
│ Miniloader 代码段             │ 245 KB
├──────────────────────────────┤
│ Miniloader 数据段             │  55 KB
├──────────────────────────────┤
│ 堆空间 (动态分配)             │  1 MB
├──────────────────────────────┤
│ USB 传输缓冲区                │  4 MB
├──────────────────────────────┤
│ U-Boot 加载区                 │  10 MB
├──────────────────────────────┤
│ Trust 加载区                  │  10 MB
├──────────────────────────────┤
│ 剩余可用内存                  │  ~2 GB
└──────────────────────────────┘
总计：充足的 DDR 空间！
```

#### 各组件代码大小详细对比

**重要澄清**：DDR 初始化代码实际上**比单独的 eMMC 驱动还要大**！

```
实际大小关系（从小到大）：
┌────────────────────────────────────────────────┐
│ 1. BootROM eMMC 简单驱动                        │
│    └─ 5-10 KB (固化在芯片 ROM 中)               │
├────────────────────────────────────────────────┤
│ 2. Miniloader eMMC 完整驱动（单独计算）          │
│    ├─ eMMC 基础协议：      ~40 KB               │
│    ├─ 高速模式 (HS200/HS400)：~30 KB            │
│    ├─ DMA 支持：           ~15 KB               │
│    └─ 总计：               ~85 KB               │
├────────────────────────────────────────────────┤
│ 3. DDR Init (完整二进制)  ⚠️ 最大！              │
│    ├─ DDR 控制器代码：     ~30 KB               │
│    ├─ DDR 训练算法：       ~40 KB               │
│    ├─ DDR 时序参数表：     ~35 KB               │
│    ├─ DDR 兼容性代码：     ~25 KB               │
│    └─ 总计：              ~130 KB               │
├────────────────────────────────────────────────┤
│ 4. Miniloader (完整二进制)                      │
│    ├─ eMMC 驱动：          ~85 KB               │
│    ├─ Rockusb 协议：      ~100 KB               │
│    ├─ USB 协议栈：         ~30 KB               │
│    ├─ 错误处理/调试：      ~30 KB               │
│    └─ 总计：              ~245 KB               │
└────────────────────────────────────────────────┘

所以正确的大小关系是：
BootROM eMMC (10KB) < Miniloader eMMC (85KB) < DDR Init (130KB) < Miniloader 总计 (245KB)
```

#### 为什么 DDR 初始化代码比 eMMC 完整驱动还大？

这确实反直觉！原因如下：

**1. 大量的参数表**

```c
// DDR Init 包含大量硬编码的参数表
struct ddr_timing_params {
    uint32_t freq_mhz;
    uint32_t cl;        // CAS Latency
    uint32_t cwl;       // CAS Write Latency
    uint32_t trcd;      // RAS to CAS Delay
    uint32_t trp;       // Row Precharge Time
    uint32_t tras;      // Row Active Time
    uint32_t trc;       // Row Cycle Time
    uint32_t trrd;      // Row to Row Delay
    uint32_t tfaw;      // Four Activate Window
    uint32_t twr;       // Write Recovery Time
    uint32_t trfc;      // Refresh Cycle Time
    uint32_t txp;       // Exit Power Down
    uint32_t txpdll;    // Exit Power Down with DLL
    uint32_t tzqcs;     // ZQ Calibration Short
    uint32_t tzqoper;   // ZQ Calibration Long
    // ... 还有 50+ 个参数
};

// 每种频率都需要一套参数
const struct ddr_timing_params timing_table[] = {
    { .freq = 666,  .cl = 10, .trcd = 15, ... }, // 66MHz
    { .freq = 800,  .cl = 11, .trcd = 16, ... }, // 800MHz
    { .freq = 933,  .cl = 13, .trcd = 17, ... }, // 933MHz
    { .freq = 1066, .cl = 14, .trcd = 18, ... }, // 1066MHz
    { .freq = 1333, .cl = 16, .trcd = 20, ... }, // 1333MHz
    { .freq = 1600, .cl = 18, .trcd = 22, ... }, // 1600MHz
    // ... 10+ 种频率配置
};

// 每种 DDR 类型（LPDDR3/LPDDR4/DDR3/DDR4）都有不同的表
// 总计：10 频率 × 4 类型 × 60 参数 × 4 字节 = ~96 KB！
```

对比 eMMC 驱动：
```c
// eMMC 驱动几乎没有参数表
// 所有配置都是运行时从 eMMC 芯片读取的 EXT_CSD
int emmc_init() {
    uint8_t ext_csd[512];
    emmc_send_cmd8(&ext_csd);  // 从芯片读取配置

    // 根据芯片返回的配置动态调整
    if (ext_csd[EXT_CSD_CARD_TYPE] & EXT_CSD_CARD_TYPE_HS200) {
        switch_to_hs200();  // 运行时决定
    }

    // 无需硬编码大量参数表！
}
```

**2. 复杂的训练算法**

```c
// DDR 训练算法（简化版）
void ddr_training() {
    // 1. Write Leveling（写平衡训练）
    for (int dqs = 0; dqs < 128; dqs++) {
        set_dqs_delay(dqs);
        if (write_test_pattern_ok()) {
            optimal_dqs = dqs;
            break;
        }
    }

    // 2. Read Gate Training（读门控训练）
    for (int gate = 0; gate < 256; gate++) {
        set_gate_delay(gate);
        if (read_test_pattern_ok()) {
            optimal_gate = gate;
            break;
        }
    }

    // 3. Read/Write DQ Training（数据线训练）
    for (int byte = 0; byte < 4; byte++) {
        for (int bit = 0; bit < 8; bit++) {
            // 对每个数据位进行窗口扫描
            scan_dq_window(byte, bit);
        }
    }

    // 4. VREF Training（参考电压训练）
    for (int vref = 0; vref < 50; vref++) {
        set_vref_voltage(vref);
        if (stability_test_ok()) {
            optimal_vref = vref;
            break;
        }
    }
}

// 这些训练算法代码量很大（~40 KB）
// 而且需要大量的测试数据模式
const uint32_t training_patterns[] = {
    0x00000000, 0xFFFFFFFF, 0x55555555, 0xAAAAAAAA,
    0x33333333, 0xCCCCCCCC, 0x0F0F0F0F, 0xF0F0F0F0,
    // ... 数百个测试模式（~10 KB）
};
```

对比 eMMC 驱动：
```c
// eMMC HS200 调谐（Tuning）相对简单
int emmc_execute_tuning() {
    // 只需要扫描一个参数（采样点）
    for (int phase = 0; phase < 128; phase++) {
        set_sample_phase(phase);
        if (send_tuning_block_ok()) {
            optimal_phase = phase;
            return 0;
        }
    }
    // 代码量小得多（~5 KB）
}
```

**3. 多 DDR 类型支持**

```
DDR Init 需要支持：
├─ LPDDR3 (移动设备)    → 独立的初始化代码 ~30 KB
├─ LPDDR4 (新移动设备)  → 独立的初始化代码 ~35 KB
├─ DDR3 (桌面/服务器)   → 独立的初始化代码 ~25 KB
└─ DDR4 (新桌面/服务器) → 独立的初始化代码 ~30 KB

每种类型的初始化流程都不同！
虽然有共用代码，但总代码量仍然很大

对比 eMMC：
  └─ eMMC 标准统一（只有版本差异，兼容性好）
     所有版本共用同一套驱动代码
```

**4. 电源和时钟管理**

```c
// DDR 需要精细的电源序列
void ddr_power_sequence() {
    // 1. 上电序列（严格时序要求）
    enable_vdd_core();
    udelay(200);  // 等待 200us
    enable_vdd_io();
    udelay(100);
    enable_vref();
    udelay(50);

    // 2. 时钟配置（需要 PLL 计算）
    configure_pll_for_ddr(target_freq);

    // 3. 校准序列
    ddr_phy_calibration();

    // 4. ZQ 校准（阻抗匹配）
    ddr_zq_calibration();

    // 大量的时序控制代码（~20 KB）
}
```

对比 eMMC：
```c
// eMMC 电源管理简单
void emmc_power_on() {
    gpio_set_value(EMMC_PWR_EN, 1);  // 开电源
    mdelay(10);                      // 等待
    emmc_send_cmd0();                // 复位
    // 简单得多（~2 KB）
}
```

#### 为什么 DDR 不能做得更小？

**已经尽力优化了！**

```
如果只支持单一配置：
├─ 只支持 LPDDR4             → 可以减少 60 KB
├─ 只支持 800MHz             → 可以减少 30 KB
├─ 去掉训练算法（用固定延迟） → 可以减少 40 KB
└─ 理论最小：                  ~40 KB

但这样会导致：
❌ 不兼容其他内存条
❌ 无法支持超频
❌ 稳定性差（温度/电压变化会出错）
❌ 良品率低（不同批次内存颗粒差异大）

所以 100-150 KB 是必需的！
```

#### 总结对比表

| 组件 | 大小 | 复杂度来源 | 能否缩小 |
|------|------|-----------|---------|
| **BootROM eMMC** | 5-10 KB | 最简协议 | ❌ 已经最小 |
| **Miniloader eMMC** | 85 KB | 完整协议栈 | ⚠️ 可以（去掉 DMA 等） |
| **DDR Init** | 130 KB | 参数表 + 训练算法 | ⚠️ 可以（牺牲兼容性） |
| **Miniloader 总计** | 245 KB | eMMC + USB + Rockusb | ⚠️ 可以（去掉烧录） |

**关键洞察**：
- DDR Init 虽然**功能单一**，但因为**参数表多**、**训练算法复杂**、**类型兼容性**，所以代码很大
- eMMC 驱动虽然**功能多**，但因为**无需参数表**（运行时读取）、**协议标准化**，所以单独看不算大
- Miniloader 大是因为 **eMMC + USB + Rockusb 协议** 的总和

---

### 为什么不在 SRAM 阶段就完整初始化 eMMC？（深度思考）

**更深的疑问**：
- DDR Init 占用 130 KB
- eMMC 完整驱动只需 85 KB
- SRAM 有 256 KB
- 理论上可以在阶段2（DDR初始化后）就在 SRAM 中完整初始化 eMMC，为什么不这么做？

#### 理论可行性分析

```
SRAM 空间（256 KB）理论分配：
┌────────────────────────────────┐
│ 方案A：当前设计（只有DDR Init）  │
├────────────────────────────────┤
│ DDR Init 代码：       120 KB   │
│ DDR Init 栈：          32 KB   │
│ DDR 训练缓冲区：       64 KB   │
│ DDR 训练结果：         32 KB   │
│ BootROM 保留：          8 KB   │
│ 总计：               256 KB ✅  │
└────────────────────────────────┘

┌────────────────────────────────┐
│ 方案B：理论方案（DDR Init + eMMC）│
├────────────────────────────────┤
│ DDR Init 代码：       120 KB   │
│ DDR Init 运行时需求：  128 KB  │ ← 占满 SRAM
│ eMMC 驱动代码：        85 KB   │ ← 无处可放！
│ eMMC 运行时需求：      40 KB   │
│ 总计：               373 KB ❌  │ ← 超出 SRAM！
└────────────────────────────────┘
```

**关键问题**：DDR Init 和 eMMC 驱动**不能同时存在于 SRAM 中**！

#### 为什么实际上不可行？

**1. DDR Init 运行时占满 SRAM**

```c
// DDR Init 的实际内存占用
void ddr_init_memory_usage() {
    // 代码段：120 KB
    // ...

    // 数据段（运行时动态使用）：
    uint8_t training_buffer[64 * 1024];    // 64 KB - 训练数据缓冲
    uint32_t training_results[8 * 1024];   // 32 KB - 保存每个bit的窗口
    uint8_t test_patterns[32 * 1024];      // 32 KB - 测试模式
    uint32_t stack[8 * 1024];              // 32 KB - 栈空间

    // 运行时总占用：120 + 128 = 248 KB
    // 剩余可用：256 - 248 = 8 KB ← 根本放不下 85KB 的 eMMC 驱动！
}
```

**实际内存时间线**：

```
T=0ms: BootROM 加载 DDR Init 到 SRAM
┌─────────────────────────────────┐
│ SRAM (256 KB)                   │
│ ├─ DDR Init 代码 (120 KB)       │
│ ├─ 训练缓冲区 (64 KB)           │
│ ├─ 训练结果 (32 KB)             │
│ ├─ 测试数据 (32 KB)             │
│ └─ 栈 (8 KB)                    │
│ 剩余：0 KB ← 满了！              │
└─────────────────────────────────┘

T=20ms: DDR Init 完成，内存可以释放
┌─────────────────────────────────┐
│ SRAM (256 KB)                   │
│ ├─ DDR Init 代码 (仍在)         │ ← 此时还没加载新代码
│ └─ 临时数据 (可以释放)          │
│ 剩余：~136 KB                   │
└─────────────────────────────────┘

如果要加载 eMMC 驱动（85 KB）：
  需要先清空 DDR Init 代码区
  但此时 BootROM 已经返回，无法再次加载！
```

**2. BootROM 的单次加载限制**

```
BootROM 的工作流程（硬件限制）：
┌──────────────────────────────────┐
│ 1. 初始化 eMMC（简单模式）        │
│    ↓                             │
│ 2. 读取 loader.bin 头部           │
│    ↓                             │
│ 3. 加载 DDR Init 到 SRAM          │ ← 只加载一次！
│    ↓                             │
│ 4. 跳转到 DDR Init 执行           │
│    ↓                             │
│ 5. DDR Init 返回                 │
│    ↓                             │
│ 6. 加载 Miniloader 到 DDR         │ ← 这是下一个组件
│    ↓                             │
│ 7. 跳转到 Miniloader              │
└──────────────────────────────────┘

❌ BootROM 不支持：
   - DDR Init 后再加载 eMMC 驱动到 SRAM
   - 在 SRAM 中切换代码段
   - 多阶段加载到同一位置

✅ BootROM 只能：
   - 线性加载：组件1 → 组件2 → 组件3
   - 一次性加载每个组件
```

**3. 即使能放下，也没必要**

假设我们魔改 BootROM，让它能在 SRAM 中加载多个组件：

```
改进方案（理论）：
T=0ms:  加载 DDR Init (130KB) 到 SRAM
T=20ms: DDR Init 执行完毕
T=21ms: 清空 SRAM，加载 eMMC 驱动 (85KB)
T=26ms: eMMC 驱动完整初始化 eMMC
T=31ms: 读取 Miniloader 到 DDR (高速)
T=34ms: 跳转到 Miniloader

当前方案：
T=0ms:  加载 DDR Init (130KB) 到 SRAM
T=20ms: DDR Init 执行完毕
T=21ms: 加载 Miniloader (245KB) 到 DDR (低速)
T=151ms: Miniloader 初始化 eMMC (高速)
T=156ms: 加载 U-Boot/Trust (高速)

时间对比：
  改进方案：34ms
  当前方案：156ms
  差距：122ms

但改进方案的问题：
❌ 需要修改 BootROM（不可能，已固化）
❌ SRAM 空间分配复杂（DDR Init运行时会占满）
❌ 增加启动流程复杂度
❌ 只节省 122ms（不值得）
```

**4. 设计哲学：简单性优先**

```
SRAM 阶段的设计原则：
┌─────────────────────────────────┐
│ 目标：尽快初始化 DDR              │
│ ├─ 代码尽量简单                  │
│ ├─ 不做额外的事情                │
│ └─ 快速切换到 DDR 阶段            │
└─────────────────────────────────┘

DDR 阶段的设计原则：
┌─────────────────────────────────┐
│ 目标：完成复杂的任务              │
│ ├─ 空间充足（2GB）                │
│ ├─ 可以加载大型驱动               │
│ ├─ 可以长时间运行（烧录模式）      │
│ └─ 可以处理复杂错误               │
└─────────────────────────────────┘

如果在 SRAM 阶段做完整 eMMC 初始化：
  ├─ 违反"简单性"原则
  ├─ 增加 SRAM 阶段的复杂度
  ├─ 节省时间有限（~100ms）
  └─ 增加调试难度
```

#### 真实的执行流程

```
实际发生的事情：

SRAM 阶段（内存紧张）：
┌────────────────────────────────┐
│ T=0ms:  BootROM 简单初始化 eMMC │
│         (低速，只能读取)         │
│ T=5ms:  读取并加载 DDR Init     │
│         (低速，130KB，耗时15ms) │
│ T=20ms: 执行 DDR Init           │
│         (初始化 2GB DDR 内存)   │
│ T=40ms: DDR Init 完成           │
│ T=41ms: BootROM 读取 Miniloader │
│         (低速，245KB，耗时130ms)│
│ T=171ms: Miniloader 开始运行    │
└────────────────────────────────┘
         ↓
DDR 阶段（内存充足）：
┌────────────────────────────────┐
│ T=171ms: Miniloader 完整初始化  │
│          eMMC (高速模式)        │
│ T=176ms: 读取 trust.img (2MB)  │
│          (高速，耗时7ms)        │
│ T=183ms: 读取 uboot.img (1MB)  │
│          (高速，耗时3ms)        │
│ T=186ms: 跳转到 U-Boot          │
└────────────────────────────────┘

总启动时间：186ms
```

#### 如果强行在 SRAM 实现？

```
假设的实现（需要硬件支持）：

SRAM 阶段：
┌────────────────────────────────┐
│ T=0ms:  BootROM 简单初始化 eMMC │
│ T=5ms:  加载 DDR Init           │
│ T=20ms: 执行 DDR Init           │
│ T=40ms: DDR Init 完成并释放内存 │
│ T=41ms: 重新加载 eMMC 驱动到SRAM│ ← 需要修改 BootROM！
│ T=46ms: 执行 eMMC 完整初始化    │
│ T=51ms: eMMC 高速模式就绪       │
│ T=52ms: 读取 Miniloader (高速)  │
│         (245KB，耗时1ms)        │
│ T=53ms: Miniloader 运行在 DDR   │
│ T=54ms: 读取 trust/uboot (高速) │
│ T=64ms: 跳转到 U-Boot           │
└────────────────────────────────┘

总启动时间：64ms
节省：122ms（65% 提升）

但代价：
❌ 需要修改 BootROM（不可能）
❌ SRAM 管理复杂（需要动态清空/重载）
❌ 调试困难（SRAM 没有打印输出）
❌ 失败就死机（无法进入烧录模式）
```

#### 总结

| 方案 | 可行性 | 启动时间 | 复杂度 | 实用性 |
|------|-------|---------|--------|--------|
| **当前设计** | ✅ 可行 | 186ms | 简单 | ✅ 好 |
| **SRAM 完整初始化** | ❌ 需硬件改动 | 64ms | 复杂 | ❌ 不可行 |

**核心原因**：
1. ✅ **理论上可行** - eMMC 驱动（85KB）确实小于 DDR Init（130KB）
2. ❌ **实际不可行** - DDR Init **运行时**占满 SRAM（248KB）
3. ❌ **BootROM 限制** - 硬件只支持线性加载，无法在 SRAM 中切换代码
4. ❌ **收益有限** - 只节省约 100ms，但增加巨大复杂度

**设计哲学**：
- SRAM 阶段：**快速简单**，只初始化 DDR
- DDR 阶段：**功能完整**，做所有复杂的事情
- 这是一个**工程上的最优解**，而非理论上的最优解

---

### eMMC 初始化的两个阶段（重要）

**常见疑问**：BootROM 已经能从 eMMC 读取 loader 了，为什么 Miniloader 还要再初始化 eMMC？

**答案**：这不是重复初始化，而是**两个不同级别**的初始化！

#### 阶段 1：BootROM 的最小化 eMMC 初始化

```
BootROM 中的 eMMC 驱动（固化在芯片中）：
┌─────────────────────────────────────┐
│ 功能：                               │
│ ✅ 基础读取（读取 loader）            │
│ ✅ 低速模式（400KHz 时钟）            │
│ ✅ 单数据线模式（1-bit）              │
│ ✅ 支持 eMMC boot 分区读取           │
│                                     │
│ 限制：                               │
│ ❌ 不支持高速模式（HS200/HS400）      │
│ ❌ 不支持 8-bit 数据总线              │
│ ❌ 不支持 DMA 传输                   │
│ ❌ 不支持擦除/写入操作                │
│ ❌ 不支持分区切换                    │
│ ❌ 代码空间受限（ROM 只有几 KB）      │
└─────────────────────────────────────┘

目的：只为了能读取 loader.bin（几百 KB）
性能：约 1-2 MB/s（够用但很慢）
```

#### 阶段 2：Miniloader 的完整 eMMC 初始化

```
Miniloader 中的 eMMC 驱动（运行在 DDR 中）：
┌─────────────────────────────────────┐
│ 功能：                               │
│ ✅ 高速读取（HS200：200MHz）          │
│ ✅ 超高速读取（HS400：400MHz）        │
│ ✅ 8-bit 数据总线                    │
│ ✅ DMA 传输（减少 CPU 负载）          │
│ ✅ 完整的读写擦除支持                 │
│ ✅ 分区管理（boot0/boot1/user）      │
│ ✅ RPMB 安全分区访问                 │
│ ✅ 坏块管理                          │
│ ✅ 支持 Rockusb 烧录协议             │
└─────────────────────────────────────┘

目的：加载大文件（uboot.img 1MB + trust.img 2MB）
      支持固件烧录（写入几 GB 数据）
性能：约 100-300 MB/s（快 100 倍！）
```

#### 对比类比

这就像：

```
BootROM 的 eMMC 驱动  =  DOS 时代的软盘驱动
  - 只能读取，速度慢
  - 功能简单，代码小
  - 够用于加载引导程序

Miniloader 的 eMMC 驱动  =  现代操作系统的 NVMe 驱动
  - 读写快速，功能完整
  - 支持所有高级特性
  - 用于日常工作
```

#### 实际性能差距

| 操作 | BootROM 模式 | Miniloader 模式 | 性能提升 |
|------|-------------|----------------|---------|
| **时钟频率** | 400 KHz | 200 MHz (HS200) | **500x** |
| **数据线宽度** | 1-bit | 8-bit | **8x** |
| **读取 1MB** | ~500 ms | ~3 ms | **166x** |
| **读取 loader (256KB)** | ~128 ms | <1 ms | **128x** |
| **读取 uboot+trust (3MB)** | ~1.5 秒 | ~10 ms | **150x** |

**为什么 BootROM 不直接用高速模式？**

1. **代码空间限制**：BootROM 通常只有 32-64 KB，完整驱动需要几百 KB
2. **兼容性优先**：低速模式兼容所有 eMMC 芯片（包括老旧型号）
3. **功耗考虑**：高速模式需要更多电源管理代码
4. **足够快了**：读取 256KB 的 loader 只需 0.1 秒，可以接受

#### 详细初始化流程对比

```c
// BootROM 的 eMMC 初始化（伪代码）
void bootrom_emmc_init() {
    // 1. 最基础的初始化
    emmc_power_on();
    emmc_send_cmd0();           // GO_IDLE
    emmc_send_cmd1();           // SEND_OP_COND
    emmc_send_cmd2();           // ALL_SEND_CID
    emmc_send_cmd3();           // SET_RELATIVE_ADDR

    // 2. 选择卡片
    emmc_send_cmd7();           // SELECT_CARD

    // 3. 设置为 1-bit 模式，400KHz
    emmc_set_bus_width(1);
    emmc_set_clock(400000);     // 400 KHz

    // 完成！可以读取了（但很慢）
}

// Miniloader 的 eMMC 初始化（伪代码）
void miniloader_emmc_init() {
    // 1. 完整的初始化序列
    emmc_power_on();
    emmc_send_cmd0();
    emmc_send_cmd1();
    emmc_send_cmd2();
    emmc_send_cmd3();
    emmc_send_cmd7();

    // 2. 读取 EXT_CSD（扩展配置）
    emmc_send_cmd8(&ext_csd);

    // 3. 切换到 8-bit 模式
    emmc_send_cmd6(EXT_CSD_BUS_WIDTH, 0x02);  // 8-bit
    emmc_set_bus_width(8);

    // 4. 切换到 HS200 模式（200MHz）
    emmc_send_cmd6(EXT_CSD_HS_TIMING, 0x02);  // HS200
    emmc_set_clock(200000000);   // 200 MHz

    // 5. 执行 HS200 调谐（Tuning）
    emmc_execute_tuning();       // 优化信号时序

    // 6. 可选：切换到 HS400（400MHz）
    if (supports_hs400()) {
        emmc_send_cmd6(EXT_CSD_HS_TIMING, 0x03);
        emmc_set_clock(400000000);  // 400 MHz
        emmc_execute_tuning();
    }

    // 7. 配置 DMA
    emmc_setup_dma();

    // 8. 配置分区
    emmc_switch_partition(EMMC_PARTITION_USER);

    // 完成！现在速度飞快！
}
```

#### 为什么需要两次初始化？

**硬件限制**：
- BootROM 运行时，DDR 还未初始化，只有 256KB SRAM
- 完整的 eMMC 驱动代码需要 200-500 KB
- SRAM 装不下完整驱动 + DDR 初始化代码 + Miniloader

**设计哲学**：
```
BootROM：           "能用就行"（最小可行）
Miniloader/U-Boot： "又快又好"（完整功能）
```

#### 启动时序示例（RK3399）

```
时间线：
T=0ms      BootROM 开始执行
T=5ms      BootROM 初始化 eMMC（低速模式）
T=10ms     BootROM 读取 DDR Init（256KB，耗时 ~130ms）
T=140ms    DDR Init 运行，初始化内存
T=150ms    BootROM 读取 Miniloader（256KB，耗时 ~130ms）
T=280ms    Miniloader 开始执行
T=285ms    Miniloader 重新初始化 eMMC（高速模式）
T=290ms    Miniloader 读取 trust.img（2MB，耗时 ~7ms）
T=297ms    Miniloader 读取 uboot.img（1MB，耗时 ~3ms）
T=300ms    跳转到 Trust/U-Boot

总结：如果 Miniloader 不重新初始化 eMMC
      读取 trust.img + uboot.img 将耗时 1.5 秒（而非 10ms）
      启动速度慢 150 倍！
```

---

## 固件镜像格式详解

### 1. uboot.img 格式

#### 头部结构（512 字节）

```c
// Rockchip Boot Header (定义在 loaderimage 源码中)
struct rk_boot_header {
    uint32_t magic;           // 0x0FF0AA55 (Rockchip 魔数)
    uint32_t size;            // 代码大小（字节）
    uint32_t load_addr;       // 加载地址（如 0x00200000）
    uint32_t reserved1;       // 保留字段
    uint32_t entry_point;     // 入口地址（通常等于 load_addr）
    uint8_t  chip[16];        // 芯片型号字符串 "RK33" (RK3399)
    uint8_t  code_crc[4];     // 代码 CRC32 校验和
    uint8_t  hash[32];        // SHA256 哈希（用于验证）
    uint8_t  reserved2[424];  // 填充到 512 字节
};
```

#### 实际示例（十六进制查看）

```bash
$ hexdump -C uboot.img | head -20

00000000  55 aa f0 0f 00 a0 0f 00  00 00 20 00 00 00 00 00  |U......... .....|
          ^^^^^^^^^ magic         ^^^^^^^^^ load_addr
                    ^^^^^^^^^ size

00000010  00 00 20 00 52 4b 33 33  00 00 00 00 00 00 00 00  |.. .RK33........|
          ^^^^^^^^^ entry         ^^^^^^^^^ chip="RK33"

00000020  3d 2f 91 ac 8f 3e a1 5c  ...（SHA256 哈希）
          ^^^^^^^^^ CRC32

00000200  14 f0 9f e5 14 f0 9f e5  ...（u-boot.bin 代码开始）
          ^^^^^^^^^ ARM 指令 ldr pc, [pc, #...]
```

#### 打包过程（loaderimage 工作流程）

```c
// 伪代码展示 loaderimage 的工作原理
void pack_uboot_image(const char* input_bin, const char* output_img,
                      uint32_t load_addr, const char* size_param) {
    // 1. 读取 u-boot.bin
    uint8_t* code = read_file(input_bin, &code_size);

    // 2. 检查大小限制
    uint32_t max_size = parse_size_param(size_param); // 如 "1024 2" = 1024KB
    if (code_size > max_size * 1024) {
        error("Code too large: %d > %d", code_size, max_size * 1024);
    }

    // 3. 构建头部
    struct rk_boot_header header = {0};
    header.magic = 0x0FF0AA55;
    header.size = code_size;
    header.load_addr = load_addr;        // 从 CONFIG_SYS_TEXT_BASE 读取
    header.entry_point = load_addr;
    strcpy(header.chip, "RK33");         // RK3399 使用 "RK33"

    // 4. 计算校验和
    header.code_crc = crc32(code, code_size);
    sha256(code, code_size, header.hash);

    // 5. 写入输出文件
    write_file(output_img, &header, sizeof(header));  // 写入头部
    write_file(output_img, code, code_size);          // 写入代码

    // 6. 对齐到 4KB（eMMC 扇区大小）
    uint32_t padding = ALIGN(code_size, 4096) - code_size;
    write_padding(output_img, padding);
}
```

---

### 2. loader.bin 格式（更复杂）

#### Loader 组成结构

```
rk3399_loader_v1.25.126.bin:
┌─────────────────────────────────────┐
│ Rockchip Loader Header (2KB)        │
│ - 魔数: 0x0FF0AA55                  │
│ - 组件数量: 2                        │
│ - 组件 1 偏移: 0x800                │
│ - 组件 2 偏移: 0x20000              │
│ - 组件 1 大小: 128KB                │
│ - 组件 2 大小: 256KB                │
├─────────────────────────────────────┤
│ 组件 1: DDR Init                     │
│ (rk3399_ddr_800MHz_v1.25.bin)       │
│ - 运行在 SRAM                        │
│ - 初始化 LPDDR3/LPDDR4/DDR3         │
│ - RC 加密（可选）                    │
├─────────────────────────────────────┤
│ 组件 2: Miniloader                   │
│ (rk3399_miniloader_v1.25.bin)       │
│ - 运行在 DDR                         │
│ - 支持 eMMC/SD/SPI 读写             │
│ - 实现 Rockusb 协议（烧录模式）      │
└─────────────────────────────────────┘
```

#### INI 配置文件的作用

```ini
# RKBOOT/RK3399MINIALL.ini
[CHIP_NAME]
NAME=RK330C              # 芯片代号（RK3399 内部代号）

[VERSION]
MAJOR=2
MINOR=50                 # 版本号 v2.50

[CODE471_OPTION]         # DDR 初始化代码（471 是 Rockchip 内部编号）
NUM=1
Path1=bin/rk33/rk3399_ddr_800MHz_v1.25.bin
Sleep=1                  # 初始化后延迟 1ms

[CODE472_OPTION]         # USB 烧录插件（用于 maskrom 模式）
NUM=1
Path1=bin/rk33/rk3399_usbplug_v1.25.bin

[LOADER_OPTION]          # Loader 组件配置
NUM=2                    # 2 个组件
LOADER1=FlashData        # 组件 1 = DDR Init
LOADER2=FlashBoot        # 组件 2 = Miniloader
FlashData=bin/rk33/rk3399_ddr_800MHz_v1.25.bin
FlashBoot=bin/rk33/rk3399_miniloader_v1.25.bin

[OUTPUT]
PATH=rk3399_loader_v1.25.126.bin  # 输出文件名
```

#### boot_merger 打包流程

```python
# 伪代码展示 boot_merger 的工作原理
def boot_merger(ini_file):
    # 1. 解析 INI 文件
    config = parse_ini(ini_file)
    chip_name = config['CHIP_NAME']['NAME']
    ddr_bin = config['LOADER_OPTION']['FlashData']
    miniloader_bin = config['LOADER_OPTION']['FlashBoot']

    # 2. 读取组件文件
    ddr_data = read_file(ddr_bin)
    miniloader_data = read_file(miniloader_bin)

    # 3. 构建 Loader Header
    header = RkLoaderHeader()
    header.magic = 0x0FF0AA55
    header.chip = chip_name
    header.num_components = 2

    # 组件 1 (DDR Init)
    header.component[0].offset = 0x800      # 2KB 偏移
    header.component[0].size = len(ddr_data)
    header.component[0].load_addr = 0xFF8C0000  # SRAM 地址
    header.component[0].delay = 1           # 延迟 1ms

    # 组件 2 (Miniloader)
    header.component[1].offset = 0x20000    # 128KB 偏移
    header.component[1].size = len(miniloader_data)
    header.component[1].load_addr = 0x00200000  # DDR 地址

    # 4. 可选：RC4 加密
    if config.get('ENCRYPTION') == 'RC4':
        ddr_data = rc4_encrypt(ddr_data, key)
        miniloader_data = rc4_encrypt(miniloader_data, key)

    # 5. 写入输出文件
    output = open(config['OUTPUT']['PATH'], 'wb')
    output.write(header.pack())           # 写入头部
    output.seek(0x800)
    output.write(ddr_data)                # 写入 DDR Init
    output.seek(0x20000)
    output.write(miniloader_data)         # 写入 Miniloader
    output.close()

    # 6. 生成 idbloader.img（用于 SD 卡）
    # SD 卡启动需要特殊的 ID Block 格式
    create_idbloader(ddr_data, miniloader_data, chip_name)
```

---

### 3. trust.img 格式（ARM64）

#### Trust 组成结构

```
trust.img (ARM64):
┌─────────────────────────────────────┐
│ Rockchip Trust Header (2KB)         │
│ - 魔数: 0x0FF0AA55                  │
│ - 组件数量: 3                        │
│ - BL30 (电源管理固件)                │
│ - BL31 (ARM Trusted Firmware)       │
│ - BL32 (OP-TEE OS)                  │
├─────────────────────────────────────┤
│ BL30 (可选)                          │
│ rk3399_bl30_v2.22.elf               │
│ - 运行在 Cortex-M0 (PMU 处理器)      │
│ - 管理电源状态转换                   │
│ - 加载地址: 0x00080000              │
├─────────────────────────────────────┤
│ BL31 (必需)                          │
│ rk3399_bl31_v1.35.elf               │
│ - 运行在 EL3 (最高权限级别)          │
│ - 初始化 TrustZone                   │
│ - 提供 PSCI 接口（电源管理）         │
│ - 加载地址: 0x00010000              │
├─────────────────────────────────────┤
│ BL32 (可选)                          │
│ rk3399_bl32_v2.01.bin (OP-TEE)      │
│ - 运行在 EL1 (Secure World)         │
│ - 提供安全服务（密钥管理/DRM）       │
│ - 加载地址: 0x08400000              │
└─────────────────────────────────────┘
```

#### ARM 异常级别（Exception Level）

```
ARM64 权限级别:
┌─────────────────────────────────────┐
│ EL3 (Exception Level 3)              │  ← BL31 (ARM Trusted Firmware)
│ - 最高权限                           │    - 管理安全/非安全世界切换
│ - 控制 TrustZone                     │    - 处理 SMC 调用
├─────────────────────────────────────┤
│ EL2 (Hypervisor)                     │  ← Hypervisor (虚拟化)
│ - 虚拟化支持                         │    - KVM/Xen
├─────────────────────────────────────┤
│ EL1 (OS Kernel)                      │  ← Linux Kernel / OP-TEE
│ - 操作系统内核                       │    Secure World: OP-TEE (BL32)
│                                      │    Normal World: Linux
├─────────────────────────────────────┤
│ EL0 (User Space)                     │  ← 应用程序
│ - 用户空间应用                       │
└─────────────────────────────────────┘
```

#### trust_merger 打包流程（ARM64）

```c
// 伪代码展示 trust_merger 的工作原理
void trust_merger(const char* ini_file, const char* rsa_mode,
                  const char* sha_mode, const char* size_param) {
    // 1. 解析 INI 文件
    IniConfig config = parse_ini(ini_file);

    // 2. 读取 BL 组件
    Component bl30 = read_component(config, "BL30_OPTION");
    Component bl31 = read_component(config, "BL31_OPTION");
    Component bl32 = read_component(config, "BL32_OPTION");

    // 3. 构建 Trust Header
    RkTrustHeader header = {0};
    header.magic = 0x0FF0AA55;
    header.version = 0x01;
    header.num_components = 0;

    // 4. 添加组件信息
    if (bl30.data) {
        header.component[header.num_components++] = {
            .load_addr = 0x00080000,      // SRAM 地址
            .size = bl30.size,
            .entry = bl30.entry,
            .offset = calculate_offset()
        };
    }

    if (bl31.data) {  // BL31 是必需的
        header.component[header.num_components++] = {
            .load_addr = 0x00010000,      // SRAM 地址
            .size = bl31.size,
            .entry = bl31.entry,          // 从 ELF 读取入口点
            .offset = calculate_offset()
        };
    }

    if (bl32.data && !ignore_bl32) {
        header.component[header.num_components++] = {
            .load_addr = 0x08400000,      // DDR 地址 (DRAM_BASE + 132M)
            .size = bl32.size,
            .entry = bl32.entry,
            .offset = calculate_offset()
        };
    }

    // 5. 可选：RSA 签名
    if (rsa_mode == "3") {  // PKCS1 v2.1
        sign_with_rsa_pkcs1_v21(&header, rsa_key);
    }

    // 6. 可选：SHA 哈希
    if (sha_mode == "2") {  // Big Endian SHA256
        compute_sha256_be(&header);
    } else {
        compute_sha256_le(&header);
    }

    // 7. 写入输出文件
    write_file("trust.img", &header, sizeof(header));
    write_component(bl30);
    write_component(bl31);
    write_component(bl32);

    // 8. 对齐到指定大小
    if (size_param) {  // 如 "--size 1024 2"
        uint32_t target_size = parse_size(size_param);
        pad_to_size("trust.img", target_size);
    }
}
```

#### ARM32 Trust 格式区别

ARM32 平台（RK3288/RK3128）使用更简单的格式：

```
trust.img (ARM32):
┌─────────────────────────────────────┐
│ Rockchip Header (512 字节)           │
│ - 魔数: 0x0FF0AA55                  │
│ - 加载地址: DRAM_BASE + 132M        │
│   (如 0x68400000)                   │
├─────────────────────────────────────┤
│ OP-TEE OS 二进制                     │
│ - 运行在 Secure Monitor Mode        │
│ - 提供安全服务                       │
└─────────────────────────────────────┘
```

使用 `loaderimage` 打包（类似 uboot.img）：

```bash
loaderimage --pack --trustos tee.bin trust.img 0x68400000 --size 1024 2
```

---

## 打包工具原理

### 1. loaderimage 工具

#### 核心功能
- 添加 Rockchip 头部
- 计算 CRC32 校验和
- 计算 SHA256 哈希
- 对齐到扇区边界

#### 关键算法

```c
// CRC32 计算（用于数据完整性验证）
uint32_t crc32(const uint8_t* data, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (int j = 0; j < 8; j++) {
            crc = (crc >> 1) ^ (0xEDB88320 & -(crc & 1));
        }
    }
    return ~crc;
}

// SHA256 哈希（用于安全验证）
void sha256(const uint8_t* data, size_t len, uint8_t hash[32]) {
    SHA256_CTX ctx;
    sha256_init(&ctx);
    sha256_update(&ctx, data, len);
    sha256_final(&ctx, hash);
}
```

---

### 2. boot_merger 工具

#### 核心功能
- 合并多个二进制组件
- 设置组件加载地址
- 生成 ID Block（SD 卡启动）

#### ID Block 格式（SD 卡启动特殊格式）

```
idbloader.img (用于 SD 卡):
┌─────────────────────────────────────┐
│ Sector 0-63: 保留                    │
│ (32KB, BootROM 不读取)               │
├─────────────────────────────────────┤
│ Sector 64: ID Block Header           │
│ - 魔数: 0xFCDC8C3B                  │
│ - 芯片 ID: 0x33333043 (RK3399)      │
├─────────────────────────────────────┤
│ Sector 65-2047: DDR Init             │
│ (rk3399_ddr_800MHz_v1.bin)          │
├─────────────────────────────────────┤
│ Sector 2048+: Miniloader             │
│ (rk3399_miniloader_v1.bin)          │
└─────────────────────────────────────┘

生成命令:
mkimage -n rk3399 -T rksd -d ddr.bin idbloader.img
cat miniloader.bin >> idbloader.img
```

BootROM 从 SD 卡启动时会：
1. 读取扇区 64，检查魔数 `0xFCDC8C3B`
2. 验证芯片 ID 是否匹配
3. 从扇区 65 开始加载 DDR Init 到 SRAM
4. 从扇区 2048 开始加载 Miniloader 到 DDR

---

### 3. trust_merger 工具

#### 核心功能
- 从 ELF 文件提取代码段
- 处理 ARM64 异常向量表
- 实现 RSA 签名（安全启动）

#### ELF 文件解析

```c
// 从 BL31 ELF 文件提取代码和入口点
void extract_elf(const char* elf_file, Component* comp) {
    Elf64_Ehdr ehdr;
    read_elf_header(elf_file, &ehdr);

    // 读取程序头表
    Elf64_Phdr phdr[ehdr.e_phnum];
    read_program_headers(elf_file, phdr, ehdr.e_phnum);

    // 查找可加载段（PT_LOAD）
    for (int i = 0; i < ehdr.e_phnum; i++) {
        if (phdr[i].p_type == PT_LOAD) {
            comp->load_addr = phdr[i].p_paddr;  // 物理地址
            comp->size = phdr[i].p_filesz;      // 文件大小
            comp->data = malloc(comp->size);

            // 读取段数据
            lseek(fd, phdr[i].p_offset, SEEK_SET);
            read(fd, comp->data, comp->size);
        }
    }

    // 入口点
    comp->entry = ehdr.e_entry;  // 如 0x00010000
}
```

---

## 加密与签名机制

### 1. RC4 加密（Loader）

部分平台支持 RC4 加密 Loader，防止逆向分析：

```c
// RC4 加密算法
void rc4_encrypt(uint8_t* data, size_t len, const uint8_t* key, size_t key_len) {
    uint8_t S[256];

    // 初始化密钥调度算法（KSA）
    for (int i = 0; i < 256; i++) {
        S[i] = i;
    }

    int j = 0;
    for (int i = 0; i < 256; i++) {
        j = (j + S[i] + key[i % key_len]) % 256;
        swap(S[i], S[j]);
    }

    // 伪随机生成算法（PRGA）
    int i = 0, j = 0;
    for (size_t k = 0; k < len; k++) {
        i = (i + 1) % 256;
        j = (j + S[i]) % 256;
        swap(S[i], S[j]);
        data[k] ^= S[(S[i] + S[j]) % 256];
    }
}
```

**注意**：BootROM 内部有对应的解密密钥。

---

### 2. RSA 签名（Secure Boot）

RK3308/PX30 支持 RSA-PKCS1 v2.1 签名验证：

```c
// RSA 签名流程
void sign_image(RkHeader* header, const uint8_t* rsa_private_key) {
    // 1. 计算镜像 SHA256 哈希
    uint8_t hash[32];
    sha256(header->code, header->code_size, hash);

    // 2. 使用 RSA 私钥签名
    RSA_PKCS1_V21_Sign(rsa_private_key, hash, 32, header->signature);

    // 3. 设置签名标志
    header->sign_flag = 0x03;  // PKCS1 v2.1
}
```

BootROM 验证流程：

```c
// BootROM 中的验证代码（伪代码）
bool verify_image(RkHeader* header, const uint8_t* rsa_public_key) {
    // 1. 计算镜像哈希
    uint8_t hash[32];
    sha256(header->code, header->code_size, hash);

    // 2. 使用公钥验证签名
    uint8_t decrypted_hash[32];
    RSA_PKCS1_V21_Verify(rsa_public_key, header->signature, decrypted_hash);

    // 3. 比较哈希值
    return memcmp(hash, decrypted_hash, 32) == 0;
}
```

**公钥烧录**：RSA 公钥烧录在 eFuse（一次性可编程存储器）中。

---

### 3. SHA 算法变体

不同平台使用不同的 SHA 实现：

| 平台 | SHA 模式 | 字节序 | 参数 |
|------|---------|--------|------|
| RK3399/RK3288 | SHA256 | Little Endian | `--sha 0` (默认) |
| RK3368 | SHA256 | Big Endian | `--sha 2` |

```c
// Big Endian SHA256（RK3368）
void sha256_be(const uint8_t* data, size_t len, uint8_t hash[32]) {
    sha256(data, len, hash);

    // 转换为大端序
    for (int i = 0; i < 8; i++) {
        uint32_t* word = (uint32_t*)&hash[i * 4];
        *word = htonl(*word);  // 主机序 → 网络序（大端）
    }
}
```

---

## 实战：手动解包与打包

### 实战 1：解包 uboot.img

```bash
# 1. 查看头部信息（十六进制）
hexdump -C uboot.img -n 512

# 2. 提取头部（512 字节）
dd if=uboot.img of=uboot_header.bin bs=512 count=1

# 3. 提取代码部分
dd if=uboot.img of=uboot_code.bin bs=512 skip=1

# 4. 查看头部字段（使用 Python）
python3 << 'EOF'
with open('uboot_header.bin', 'rb') as f:
    header = f.read(512)

    magic = int.from_bytes(header[0:4], 'little')
    size = int.from_bytes(header[4:8], 'little')
    load_addr = int.from_bytes(header[8:12], 'little')
    chip = header[16:20].decode('ascii').rstrip('\x00')

    print(f"Magic: 0x{magic:08X}")
    print(f"Size: {size} bytes ({size/1024:.1f} KB)")
    print(f"Load Address: 0x{load_addr:08X}")
    print(f"Chip: {chip}")
EOF

# 输出示例：
# Magic: 0x0FF0AA55
# Size: 1024576 bytes (1000.6 KB)
# Load Address: 0x00200000
# Chip: RK33
```

---

### 实战 2：手动打包 uboot.img

```python
#!/usr/bin/env python3
import struct
import hashlib

def pack_uboot_image(input_bin, output_img, load_addr):
    # 1. 读取 u-boot.bin
    with open(input_bin, 'rb') as f:
        code = f.read()

    code_size = len(code)

    # 2. 构建头部
    header = bytearray(512)

    # 魔数
    struct.pack_into('<I', header, 0, 0x0FF0AA55)

    # 大小
    struct.pack_into('<I', header, 4, code_size)

    # 加载地址
    struct.pack_into('<I', header, 8, load_addr)

    # 入口点
    struct.pack_into('<I', header, 16, load_addr)

    # 芯片型号
    header[20:24] = b'RK33'

    # CRC32 校验和
    import zlib
    crc = zlib.crc32(code) & 0xFFFFFFFF
    struct.pack_into('<I', header, 24, crc)

    # SHA256 哈希
    sha = hashlib.sha256(code).digest()
    header[28:60] = sha

    # 3. 写入输出文件
    with open(output_img, 'wb') as f:
        f.write(header)
        f.write(code)

        # 4. 对齐到 4KB
        padding = (4096 - (code_size % 4096)) % 4096
        f.write(b'\x00' * padding)

    print(f"Packed: {output_img}")
    print(f"  Code size: {code_size} bytes")
    print(f"  Load addr: 0x{load_addr:08X}")

# 使用示例
pack_uboot_image('u-boot.bin', 'uboot_manual.img', 0x00200000)
```

---

### 实战 3：解析 loader.bin 组件

```bash
# 1. 查看 Loader Header
hexdump -C rk3399_loader_v1.25.126.bin -n 2048

lyc@ubuntu:~/Desktop/OrangePiRK3399/uboot$ hexdump -C  ./rk3399_loader_v1.22.119.bin -n 2048
00000000  42 4f 4f 54 66 00 19 01  00 00 00 00 03 01 e9 07  |BOOTf...........|
00000010  0c 06 01 29 21 43 30 33  33 01 66 00 00 00 39 01  |...)!C033.f...9.|
00000020  9f 00 00 00 39 02 d8 00  00 00 39 00 01 00 00 00  |....9.....9.....|
00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000060  00 00 00 00 00 00 39 01  00 00 00 72 00 6b 00 33  |......9....r.k.3|
00000070  00 33 00 39 00 39 00 5f  00 64 00 64 00 72 00 5f  |.3.9.9._.d.d.r._|
00000080  00 38 00 30 00 30 00 4d  00 48 00 7a 00 5f 00 76  |.8.0.0.M.H.z._.v|
00000090  00 00 00 4a 01 00 00 00  30 01 00 01 00 00 00 39  |...J....0......9|
000000a0  02 00 00 00 72 00 6b 00  33 00 33 00 39 00 39 00  |....r.k.3.3.9.9.|
000000b0  5f 00 75 00 73 00 62 00  70 00 6c 00 75 00 67 00  |_.u.s.b.p.l.u.g.|
000000c0  5f 00 76 00 31 00 2e 00  31 00 00 00 4a 31 01 00  |_.v.1...1...J1..|
000000d0  00 f0 00 00 00 00 00 00  39 04 00 00 00 46 00 6c  |........9....F.l|
000000e0  00 61 00 73 00 68 00 44  00 61 00 74 00 61 00 00  |.a.s.h.D.a.t.a..|
000000f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000100  00 00 00 00 00 4a 21 02  00 00 30 01 00 00 00 00  |.....J!...0.....|
00000110  00 39 04 00 00 00 46 00  6c 00 61 00 73 00 68 00  |.9....F.l.a.s.h.|
00000120  42 00 6f 00 6f 00 74 00  00 00 00 00 00 00 00 00  |B.o.o.t.........|
00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 4a 51  |..............JQ|
00000140  03 00 00 58 01 00 00 00  00 00 3c 6d 1f c0 65 bb  |...X......<m..e.|
00000150  9d 45 ea 77 b4 1c 20 40  01 4d 00 48 f1 e3 c5 53  |.E.w.. @.M.H...S|
00000160  97 6d 20 99 d5 68 d9 ba  f9 62 b3 bb 54 3f c9 68  |.m ..h...b..T?.h|
00000170  62 da ad 9d 6e 36 3c 88  ae 59 9a 2c 57 c9 dd 18  |b...n6<..Y.,W...|
00000180  40 c3 a7 e1 ce de e2 4e  8e 15 60 96 20 e0 b5 e0  |@......N..`. ...|
00000190  fc 14 8f f9 27 4b 0d 82  50 5b 9f 86 b4 6b 4b f9  |....'K..P[...kK.|
000001a0  7a 0b 8b 54 6f 88 bb 05  12 e8 13 be f5 00 ca bb  |z..To...........|
000001b0  74 6c d6 3f 1a 4b 26 72  30 91 cb fb f2 c8 7a 98  |tl.?.K&r0.....z.|
000001c0  9c 3d 26 1d a0 a0 f8 b6  bd 95 25 54 1f 4a 82 ee  |.=&.......%T.J..|
000001d0  f9 cc 52 96 59 b3 b3 e9  71 b3 0d 31 d5 3f 99 6f  |..R.Y...q..1.?.o|
000001e0  c1 40 bd f4 ff 14 88 8b  d5 3e 49 6c 7a cf 2c 3d  |.@.......>Ilz.,=|
000001f0  1a 1c 3f 1b 40 e7 e0 d2  73 0a f9 e8 eb 8c ee 13  |..?.@...s.......|
00000200  d3 e8 20 ba af cd ae 3b  b2 5c d2 22 84 ab 98 02  |.. ....;.\."....|
00000210  88 fa ba 7e a8 d2 e2 82  51 67 c4 87 a4 e6 55 df  |...~....Qg....U.|
00000220  3d a2 b8 68 8f 55 55 c3  08 3b 3e ee 5a bc 22 20  |=..h.UU..;>.Z." |
00000230  76 29 a0 39 39 d4 c5 9a  b0 35 a9 ed 62 e3 0f 4e  |v).99....5..b..N|
00000240  a4 1d a8 37 b1 d4 b6 27  46 8a 8e f8 ba 2a f2 1e  |...7...'F....*..|
00000250  e0 b4 ea 16 e4 46 2d fb  90 06 d5 e3 07 a2 45 cf  |.....F-.......E.|
00000260  b8 25 2f 95 f9 9c 7d d9  11 ed e4 4f be 64 fd 78  |.%/...}....O.d.x|
00000270  07 2c 55 ec d6 29 fc a8  0c 06 bc d7 7e 2f 02 30  |.,U..)......~/.0|
00000280  6e 6e 26 b5 41 a1 af 53  38 23 80 5d 4d b7 8d 2f  |nn&.A..S8#.]M../|
00000290  d9 65 ca 70 bc 41 97 ea  03 40 10 7e 00 b4 2d b2  |.e.p.A...@.~..-.|
000002a0  f9 fe 00 ba 1a 0c cd 7b  77 eb 7c c2 c8 0c a9 a5  |.......{w.|.....|
000002b0  4a 41 44 82 9d 32 d2 2f  a1 50 38 0f 00 8e 06 f8  |JAD..2./.P8.....|
000002c0  31 ad f8 4f 2a f0 fb 43  77 db 30 d7 f8 d1 e3 27  |1..O*..Cw.0....'|
000002d0  ca c9 4c aa 73 d8 23 96  27 32 07 45 c4 74 8e 9c  |..L.s.#.'2.E.t..|
000002e0  eb 9f 46 6f dd 87 03 12  8c b8 46 14 a0 56 0f af  |..Fo......F..V..|
000002f0  26 63 a3 98 75 85 ef a4  f5 75 ca 27 62 e6 4f dc  |&c..u....u.'b.O.|
00000300  2a 22 68 a2 4d 6e 2d 71  7a a0 bf 3a 98 b3 7f 57  |*"h.Mn-qz..:...W|
00000310  8e 06 c3 32 14 58 18 09  a8 75 83 95 bd 7a f8 87  |...2.X...u...z..|
00000320  43 8c 1c 7a 5c 0c 6a 54  d7 b5 ee 0b 75 5f 1b 5e  |C..z\.jT....u_.^|
00000330  42 d4 76 cd af 4a 5d 36  59 06 44 cc e7 44 f8 06  |B.v..J]6Y.D..D..|
00000340  c3 ff b2 8d 6f 87 bc 2e  27 fc 84 a3 52 30 d1 85  |....o...'...R0..|
00000350  0b 80 44 e9 52 2a 9a c2  7d f0 59 45 f9 2a 91 9e  |..D.R*..}.YE.*..|
00000360  ab c1 05 6f 3a 9b 60 61  d1 97 a6 e7 c7 de c4 09  |...o:.`a........|
00000370  3c e4 e6 c6 cd fc cf 99  a6 9a 00 67 ee e7 8b 84  |<..........g....|
00000380  65 d0 5d a1 b1 c6 37 e4  84 58 e2 1b ae 28 5f 2c  |e.]...7..X...(_,|
00000390  06 b0 25 69 c3 c5 c1 ab  b8 e7 6d 02 e4 99 b1 f2  |..%i......m.....|
000003a0  ba a2 cd 57 4a 86 27 8f  91 17 61 a4 f6 f3 6c 29  |...WJ.'...a...l)|
000003b0  56 74 f0 67 38 14 05 de  d9 52 4c b9 b0 03 2a cd  |Vt.g8....RL...*.|
000003c0  65 0b 85 c9 87 0b f6 9d  45 b7 5a 46 13 85 1a 77  |e.......E.ZF...w|
000003d0  d7 48 c0 9e 3e cf a5 fd  2d d5 6d 93 49 23 6c 58  |.H..>...-.m.I#lX|
000003e0  aa 6a f3 f1 0c 44 8f bd  5a dc e0 98 46 ce de 16  |.j...D..Z...F...|
000003f0  65 36 a7 66 d3 45 e3 9b  67 b4 66 17 fa 10 75 e8  |e6.f.E..g.f...u.|
00000400  1c e3 ff 39 84 d2 70 da  f6 8a 75 05 4a 1e 5b 00  |...9..p...u.J.[.|
00000410  b8 63 49 4a 35 b5 56 72  32 0b ff bc d5 7a 23 46  |.cIJ5.Vr2....z#F|
00000420  2b db 22 e5 a0 d5 ab a7  5d aa f7 54 c1 47 85 45  |+.".....]..T.G.E|
00000430  d2 00 48 2b 06 f3 cb c8  34 a3 2d 26 49 4a e5 7d  |..H+....4.-&IJ.}|
00000440  06 37 d6 d1 aa 2f 92 2b  bd b5 c7 2a 54 35 e1 ec  |.7.../.+...*T5..|
00000450  17 4e 6b 08 25 5c 01 94  49 08 56 30 a1 cd 1e 2e  |.Nk.%\..I.V0....|
00000460  61 bf 55 81 4d 68 fb 0a  2f 66 16 40 09 84 7b 5c  |a.U.Mh../f.@..{\|
00000470  2c d3 5c 7e 4d 70 25 9e  0f 58 ea ba 65 83 8b bb  |,.\~Mp%..X..e...|
00000480  2f 24 e3 45 c6 ac 62 d2  0b bf 53 17 fe 34 f4 a0  |/$.E..b...S..4..|
00000490  d3 85 a3 18 c5 50 36 1a  ef 6c 71 1f ad f8 a4 4f  |.....P6..lq....O|
000004a0  e5 aa 20 8b ae a7 6b ac  08 6a 75 3d b3 39 c6 f7  |.. ...k..ju=.9..|
000004b0  fb 2a 23 07 5d 86 e3 85  ca 9f a9 7f 38 64 9b dc  |.*#.].......8d..|
000004c0  96 02 7a af 99 f3 a7 f2  7b bf bb e1 4f 3e 45 73  |..z.....{...O>Es|
000004d0  7b 99 44 bf 15 b9 73 c5  31 70 9c 0b b3 8f 5c c3  |{.D...s.1p....\.|
000004e0  14 96 97 5a da 5d f6 cc  11 41 e0 c5 78 71 ac 16  |...Z.]...A..xq..|
000004f0  a0 76 b1 e9 bd 49 b1 19  c8 74 35 b0 21 18 e1 00  |.v...I...t5.!...|
00000500  48 6b 65 4d f6 5d db 75  36 ea 1e 9c 6a fb de 3d  |HkeM.].u6...j..=|
00000510  9c 28 2f 1d a2 3e df ee  9f 7d 9f d2 af 73 3a ec  |.(/..>...}...s:.|
00000520  77 f7 91 ed aa 7f e4 4b  b5 d9 2b 02 7c 7d de 50  |w......K..+.|}.P|
00000530  95 76 c9 d8 02 93 74 56  b9 2a e0 7d e7 ed 41 c1  |.v....tV.*.}..A.|
00000540  2a fd ff cc 43 84 5c 44  e8 6e 8c 9e b1 58 87 2f  |*...C.\D.n...X./|
00000550  36 05 b7 74 dc 35 ef 72  43 97 ae 7d fd 43 04 05  |6..t.5.rC..}.C..|
00000560  bb 17 28 be ec 26 9c 3a  20 8c 35 50 66 21 7f 63  |..(..&.: .5Pf!.c|
00000570  25 65 2b 67 90 2a a2 e2  73 f5 bc 81 1c ee 78 c4  |%e+g.*..s.....x.|
00000580  ce 62 79 00 d5 83 0f 69  3d a3 64 09 af 69 91 a6  |.by....i=.d..i..|
00000590  0f 56 84 98 c0 a9 95 b7  ca d3 0e 36 80 6c c9 52  |.V.........6.l.R|
000005a0  99 8b 5f 1f 4c b2 49 92  f6 44 17 8e b0 33 5e 6b  |.._.L.I..D...3^k|
000005b0  df 72 99 ce 1d 6b 35 9e  05 e2 91 ca ae c8 97 52  |.r...k5........R|
000005c0  86 9e 6b e3 61 cb c7 46  0e 72 aa 0f 80 cf 65 cf  |..k.a..F.r....e.|
000005d0  6d 7e d5 2d cf df 9c d9  e3 f3 7a bb 2a b9 f9 da  |m~.-......z.*...|
000005e0  31 7e db c3 00 81 8a a2  e1 c2 fb ed a9 e9 9d da  |1~..............|
000005f0  fa 5f 80 d9 6c e8 b2 b1  73 a1 40 b0 0c 49 23 2c  |._..l...s.@..I#,|
00000600  3c 7e dc d7 8a 15 49 b8  d7 cb f5 94 6e 9b de b9  |<~....I.....n...|
00000610  f7 49 b8 f7 48 d0 52 42  15 e6 c5 9c 8e af b3 aa  |.I..H.RB........|
00000620  0e 5e 4d cc 30 66 03 86  5f 63 a3 a5 2c 3f 9e e9  |.^M.0f.._c..,?..|
00000630  32 fc 31 0b dc 27 fd 8c  9e 78 54 41 bd 86 17 54  |2.1..'...xTA...T|
00000640  cb 5c 0a 07 e4 21 ea 1b  07 55 f7 05 7a a1 6a bb  |.\...!...U..z.j.|
00000650  cb ff 96 39 80 3f df 94  9c 9c 44 43 bf b3 99 2b  |...9.?....DC...+|
00000660  d0 0b 42 b6 cd 6a fa 75  f3 55 72 b4 eb b4 65 c3  |..B..j.u.Ur...e.|
00000670  16 8f fe 40 a4 67 3d 68  1c 36 53 ee 4e b0 25 2a  |...@.g=h.6S.N.%*|
00000680  81 85 97 ea a0 a1 99 02  7e 44 cf ae b1 0d ee 40  |........~D.....@|
00000690  56 d5 92 c5 04 9d 9a 7a  c7 ce 5b 9e 3f d6 18 3d  |V......z..[.?..=|
000006a0  0d 3d 8e 38 e0 63 45 fc  3e 84 e0 0d 48 6f ad fe  |.=.8.cE.>...Ho..|
000006b0  8d 6e 05 b4 65 b4 b2 be  dc 28 12 01 d3 03 c6 f5  |.n..e....(......|
000006c0  71 c9 dd 1f 23 86 0c d4  02 3a 9d da 09 c1 b2 7e  |q...#....:.....~|
000006d0  4a 97 38 cf 0c 2a 08 99  d4 91 8e cc 29 59 aa ee  |J.8..*......)Y..|
000006e0  c2 40 92 d6 53 f3 87 40  58 88 b7 57 f2 39 a9 03  |.@..S..@X..W.9..|
000006f0  b9 70 f4 c8 a1 48 b2 c1  f4 94 f5 15 2b 62 d7 ce  |.p...H......+b..|
00000700  1c 6b 62 1d d8 18 16 01  f6 c6 ab 79 e4 a7 7e d1  |.kb........y..~.|
00000710  3a 01 b2 a9 82 3e 69 07  d5 72 a1 f7 c2 e7 82 3c  |:....>i..r.....<|
00000720  3a 8f 61 44 a4 c3 12 aa  cb 7d 34 b6 84 79 07 09  |:.aD.....}4..y..|
00000730  0a 44 29 2b 55 89 7f 12  e1 04 49 eb 0f be 7f f1  |.D)+U.....I.....|
00000740  79 75 76 6e 55 7e df 45  5f 67 6b 77 c8 11 50 67  |yuvnU~.E_gkw..Pg|
00000750  66 5f ce 05 04 01 04 1c  b1 4b f9 e9 09 b6 b9 fa  |f_.......K......|
00000760  32 6c e9 f3 41 d3 1f af  fe f7 f2 c7 91 9e ef 50  |2l..A..........P|
00000770  8e d1 2b bc 17 22 94 4f  7c 31 a5 31 54 2e 8e 9a  |..+..".O|1.1T...|
00000780  ba 86 3d ec 07 75 af c6  bd f1 a6 7c f0 51 cd 3e  |..=..u.....|.Q.>|
00000790  30 ca 57 60 db dc 6e 8c  0d 6a a8 73 8f 42 9e 99  |0.W`..n..j.s.B..|
000007a0  be a5 c0 69 1b d3 00 3d  6c 0c aa 96 04 73 65 fa  |...i...=l....se.|
000007b0  d1 c7 15 89 d2 5d 42 8b  ca 5b e5 93 c2 96 60 2b  |.....]B..[....`+|
000007c0  5a 6f b2 2c 35 ef cd 1f  47 be 0c f4 5c e6 c5 10  |Zo.,5...G...\...|
000007d0  97 b5 c3 c5 26 48 a2 de  68 da bc 2a 67 bc bd 31  |....&H..h..*g..1|
000007e0  cd f1 ee 15 cc 7b 7a a7  e8 b4 68 83 f9 f7 88 0c  |.....{z...h.....|
000007f0  70 ae a5 f4 ff 24 93 fd  1e 2e d1 46 dd 44 70 c4  |p....$.....F.Dp.|
00000800
lyc@ubuntu:~/Desktop/OrangePiRK3399/uboot$ 


# 2. 提取 DDR Init（从偏移 0x800 开始）
dd if=rk3399_loader_v1.25.126.bin of=ddr_init.bin bs=1 skip=2048 count=131072

# 3. 提取 Miniloader（从偏移 0x20000 开始）
dd if=rk3399_loader_v1.25.126.bin of=miniloader.bin bs=1 skip=131072

# 4. 反汇编 Miniloader（ARM 代码）
arm-linux-gnueabihf-objdump -D -b binary -m arm miniloader.bin > miniloader.asm

# 5. 查看字符串（寻找调试信息）
strings miniloader.bin | grep -i "rockchip\|miniloader\|version"
```

---

### 实战 4：修改 Trust 组件

```bash
# 场景：禁用 OP-TEE，减少启动时间

# 1. 备份原始 trust.img
cp trust.img trust.img.bak

# 2. 使用 --ignore-bl32 重新打包
cd ../rkbin
../uboot/tools/trust_merger \
    --replace tools/rk_tools/ ./ \
    --ignore-bl32 \
    RKTRUST/RK3399TRUST.ini

# 3. 替换新生成的 trust.img
mv trust.img ../uboot/

# 对比大小：
# 带 OP-TEE: trust.img = 2MB
# 无 OP-TEE: trust.img = 512KB
```

---

## 总结

### 打包的本质

| 步骤 | 原理 | 工具 |
|------|------|------|
| **1. 添加头部** | 让 BootROM 识别固件类型 | loaderimage / boot_merger |
| **2. 设置地址** | 指示代码加载到内存的位置 | 从 .config 读取 |
| **3. 计算校验** | 确保数据传输完整性（CRC32） | loaderimage |
| **4. 签名验证** | 防止恶意固件（RSA/SHA256） | trust_merger |
| **5. 对齐填充** | 匹配 Flash 扇区大小（4KB） | 所有工具 |

### 关键技术点

1. **魔数识别**：BootROM 通过 `0x0FF0AA55` 识别 Rockchip 固件
2. **多级加载**：BootROM → DDR Init → Miniloader → Trust → U-Boot
3. **安全启动**：RSA 签名确保只有授权固件可以运行
4. **灵活配置**：INI 文件控制组件版本和参数

### 调试技巧

```bash
# 1. 验证固件魔数
xxd -l 4 uboot.img
# 应显示: 55 aa f0 0f

# 2. 比较两个固件的差异
cmp -l uboot_old.img uboot_new.img | head

# 3. 查看编译时的加载地址
grep CONFIG_SYS_TEXT_BASE .config

# 4. 检查固件大小是否超限
ls -lh uboot.img trust.img *_loader_*.bin
```

---

**文档版本**：v1.0
**最后更新**：2025-12-07
**作者**：Claude Sonnet 4.5
