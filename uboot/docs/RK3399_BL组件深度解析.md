# Rockchip RK3399 BL 组件深度解析

## 目录
1. [BL 命名规范与 ARM Trusted Firmware 架构](#bl-命名规范)
2. [BL2 - 早期启动固件 (SPL/TPL)](#bl2---早期启动固件-spltpl)
3. [BL30 - 电源管理单元固件](#bl30-电源管理单元固件)
4. [BL31 - ARM Trusted Firmware](#bl31-arm-trusted-firmware)
5. [BL32 - OP-TEE 安全操作系统](#bl32-op-tee-安全操作系统)
6. [BL33 - U-Boot Bootloader](#bl33-u-boot-bootloader)
7. [完整启动流程与 BL 组件交互](#完整启动流程)
8. [打包方式详解](#打包方式详解)
9. [源码来源与编译](#源码来源与编译)
10. [实战：自定义 BL 组件](#实战自定义-bl-组件)

---

## BL 命名规范

### ARM Trusted Firmware 标准

BL (Boot Loader) 是 **ARM Trusted Firmware** 定义的启动阶段命名规范：

```
BL1  → Boot ROM (固化在芯片中，厂商提供)
BL2  → Trusted Boot Firmware (可选，很少使用) (loader.bin = DDR Init + Miniloader)
BL30 → 芯片厂商自定义组件 (Rockchip: PMU 固件)
BL31 → EL3 Runtime Firmware (ARM Trusted Firmware)
BL32 → Secure-EL1 Payload (OP-TEE / Trusty)
BL33 → Non-Secure Bootloader (U-Boot / UEFI)
```

### Rockchip 的 BL 定义

| 组件 | ARM 标准名称 | Rockchip 实现 | 运行环境 | 是否必需 |
|------|-------------|--------------|---------|---------|
| **BL1** | Boot ROM | BootROM (芯片内部) | 芯片内部 ROM | ✅ 必需 |
| **BL2** | Trusted Boot FW | (未使用) | - | ❌ 不使用 (loader.bin = DDR Init + Miniloader)|
| **BL30** | SCP Firmware | PMU 固件 | Cortex-M0 MCU | ⚠️ 可选 |
| **BL31** | EL3 Runtime | ATF (ARM Trusted Firmware) | EL3 (最高权限) | ✅ 必需 |
| **BL32** | Secure Payload | OP-TEE OS | Secure EL1 | ⚠️ 可选 |
| **BL33** | Non-Secure BL | U-Boot | Normal EL2/EL1 | ✅ 必需 |

---

## BL2 - 早期启动固件 (SPL/TPL)

### 1. BL2 在 ARM 架构中的定义

根据 ARM Trusted Firmware 标准，BL2 是 **Trusted Boot Firmware**，负责：

```
BL2 的标准职责：
├─ 初始化 DDR 内存
├─ 验证后续固件签名（Secure Boot）
├─ 加载 BL30/BL31/BL32/BL33 到内存
└─ 跳转到 BL31 (ATF)
```

### 2. BL2 与 U-Boot SPL/TPL 的关系

**U-Boot 启动阶段**

> **注意**：虽然 SPL 叫 "Secondary"（第二），TPL 叫 "Tertiary"（第三），但实际执行顺序是 **TPL → SPL → U-Boot**。
> 这个命名来源于历史：最初只有 SPL（第二级，相对于 BootROM 第一级），后来为了支持更小的 SRAM 环境，才引入了 TPL（第三级）作为 SPL 之前的阶段。

```
传统 U-Boot 多阶段启动（实际执行顺序）：
┌─────────────────────────────────────────┐
│ 0. BootROM (BL1)                        │
│    - 芯片固化代码                         │
│    - 加载 TPL 到 SRAM                    │
├─────────────────────────────────────────┤
│ 1. TPL (Tertiary Program Loader)  ← 第1步│
│    - 最早执行的 U-Boot 代码               │
│    - 通常在 SRAM 中运行 (256KB)          │
│    - 主要任务：初始化 DDR                 │
│    - 体积极小 (10-20KB)                  │
├─────────────────────────────────────────┤
│ 2. SPL (Secondary Program Loader) ← 第2步│
│    - 在 DDR 可用后运行                    │
│    - 初始化存储设备 (eMMC/SD)            │
│    - 加载完整 U-Boot 和 ATF 组件         │
│    - 体积中等 (50-100KB)                 │
├─────────────────────────────────────────┤
│ 3. U-Boot Proper (BL33)           ← 第3步│
│    - 完整功能的 Bootloader               │
│    - 提供命令行、网络启动等               │
│    - 加载 Linux Kernel                   │
└─────────────────────────────────────────┘

实际执行流程：
BootROM → TPL → SPL → U-Boot Proper → Linux
```

**BL2 与 SPL/TPL 的对应关系**
```
ARM ATF 概念    ←→    U-Boot 实现
────────────────────────────────
BL1 (BootROM)   ←→    芯片固化 ROM
BL2             ←→    TPL + SPL
BL31 (ATF)      ←→    arm-trusted-firmware
BL32 (TEE)      ←→    OP-TEE OS
BL33            ←→    U-Boot Proper
```

### 3. Rockchip RK3399 的 BL2 实现

**❌ Rockchip 不使用标准 BL2**

Rockchip 用自己的 **loader.bin** 替代了 ARM 标准的 BL2，架构如下：

```
loader.bin 的组成：
┌─────────────────────────────────────────┐
│ FlashData (512B)                         │
│ - 芯片类型标识 (RK3399)                   │
│ - 启动模式 (eMMC/SD/SPI)                 │
├─────────────────────────────────────────┤
│ FlashBoot (4KB)                          │
│ - BootROM 引导代码                        │
│ - 负责加载 DDR Init                       │
├─────────────────────────────────────────┤
│ DDR Init Binary (~20KB)    ← TPL 阶段   │
│ - LPDDR3/LPDDR4 初始化                   │
│ - 内存时序配置                            │
│ - 运行在 SRAM (0xFF8C0000)               │
├─────────────────────────────────────────┤
│ Miniloader Binary (~60KB)  ← SPL 阶段   │
│ - eMMC/SD 高速模式初始化                  │
│ - 加载 trust.img (BL30/31/32)           │
│ - 加载 uboot.img (BL33)                  │
│ - 运行在 DDR (0x00000000)                │
└─────────────────────────────────────────┘
```

### 4. DDR Init 详解 (TPL 阶段)

**文件信息**
```ini
# 在 RKBOOT/*.ini 中的配置
[LOADER_OPTION]
NUM=2

[FLASH_DATA]
PATH=bin/rk33/rk3399_ddr_800MHz_v1.25.bin    # DDR 初始化固件
```

**DDR Init 的主要任务**
```c
// DDR 初始化伪代码流程
void ddr_init_main() {
    // 1. 检测 DDR 类型 (LPDDR3/LPDDR4)
    ddr_type = detect_ddr_type();

    // 2. 配置 DDR PHY (物理层)
    configure_ddr_phy(ddr_type);

    // 3. 配置 DDR 控制器
    configure_ddr_controller(
        freq = 800MHz,           // 工作频率
        ranks = 2,               // 通道数
        row_bits = 15,           // 行地址位
        col_bits = 10,           // 列地址位
        bank_bits = 3            // Bank 数量
    );

    // 4. 执行 DDR 训练 (Training)
    ddr_training_sequence();     // 最耗时的步骤

    // 5. 内存测试
    if (!simple_memory_test(0x00000000, 0x1000)) {
        panic("DDR Init Failed!");
    }

    // 6. 通知 BootROM: DDR 初始化完成
    return_to_bootrom(DDR_READY);
}
```

**DDR 训练 (Training)**
```
为什么需要 DDR Training？
- LPDDR4 工作频率高达 800MHz-1600MHz
- 信号传输延迟受温度、电压、PCB 布线影响
- 需要动态校准：
  ├─ Write Leveling (写平衡)
  ├─ Read Gate Training (读门训练)
  ├─ Read/Write DQ Training (数据线训练)
  └─ Vref Training (参考电压训练)

训练时间：~10-20ms (启动时最耗时的步骤)
```

**实际文件示例**
```bash
$ ls -lh rkbin/bin/rk33/rk3399_ddr_*.bin
-rw-r--r-- 1 user user  18K  rk3399_ddr_800MHz_v1.25.bin
-rw-r--r-- 1 user user  20K  rk3399_ddr_933MHz_v1.25.bin
-rw-r--r-- 1 user user  22K  rk3399_ddr_1333MHz_v1.30.bin

# 不同版本对应不同的 DDR 频率
# 更高频率 = 更大的二进制文件 (更复杂的训练算法)
```

### 5. Miniloader 详解 (SPL 阶段)

**文件信息**
```ini
# 在 RKBOOT/*.ini 中的配置
[LOADER_OPTION]
NUM=2

[FLASH_LOADER]
PATH=bin/rk33/rk3399_miniloader_v1.26.bin    # Miniloader 固件
```

**Miniloader 的主要任务**
```c
// Miniloader 伪代码流程
void miniloader_main() {
    // 1. 初始化串口 (调试输出)
    uart_init(UART2, 1500000);
    printf("Rockchip Miniloader v1.26\n");

    // 2. 检测启动设备
    boot_device = detect_boot_device();  // eMMC/SD/SPI

    // 3. 初始化存储设备 (高速模式)
    if (boot_device == EMMC) {
        emmc_init();
        emmc_set_timing(HS200_MODE);  // 200MHz 高速模式
    }

    // 4. 读取分区表 (GPT)
    gpt_parse(boot_device);

    // 5. 加载 trust.img (BL30/31/32)
    load_partition("trust", 0x00000000);
    parse_trust_image();

    // 6. 加载 uboot.img (BL33)
    load_partition("uboot", 0x00200000);

    // 7. 跳转到 BL31 (ATF)
    jump_to_bl31(0x00010000);
}
```

**Miniloader vs U-Boot SPL**

| 特性 | Rockchip Miniloader | U-Boot SPL |
|------|---------------------|------------|
| **体积** | ~60KB | ~100KB |
| **功能** | 仅加载固件 | 可扩展命令 |
| **启动速度** | 极快 (~20ms) | 较慢 (~50ms) |
| **源码** | ❌ 闭源 (Rockchip) | ✅ 开源 (U-Boot) |
| **可定制性** | ❌ 无法修改 | ✅ 可自由修改 |
| **厂商** | Rockchip 专用 | 通用方案 |

**为什么 Rockchip 使用 Miniloader？**
```
优势：
✅ 启动速度快 (精简功能)
✅ 体积小 (节省 SRAM 空间)
✅ 稳定性高 (厂商优化)

劣势：
❌ 闭源，无法调试
❌ 功能固定，无法扩展
❌ 绑定 Rockchip 生态
```

### 6. loader.bin 的打包过程

**打包工具：boot_merger**
```bash
# uboot/make.sh 中的打包逻辑
pack_loader_image() {
    # 1. 查找 DDR Init 和 Miniloader
    INI_FILE=../rkbin/RKBOOT/RK3399MINIALL.ini

    # 2. 使用 boot_merger 打包
    ${RKTOOLS}/boot_merger ${INI_FILE}

    # 3. 生成的文件
    # - loader.bin      (用于 USB 烧录)
    # - idbloader.img   (用于 SD 卡启动)
}
```

**RKBOOT/*.ini 配置示例**
```ini
[CHIP_NAME]
NAME=RK3399

[VERSION]
MAJOR=1
MINOR=26

[CODE471_OPTION]
NUM=1
Path1=bin/rk33/rk3399_ddr_800MHz_v1.25.bin    # DDR Init (TPL)
Sleep=1

[CODE472_OPTION]
NUM=1
Path1=bin/rk33/rk3399_usbplug_v1.26.bin       # Miniloader (SPL)

[LOADER_OPTION]
NUM=2
LOADER1=FlashData                              # 启动配置
LOADER2=FlashBoot                              # 引导代码
FlashData=bin/rk33/rk3399_ddr_800MHz_v1.25.bin
FlashBoot=bin/rk33/rk3399_miniloader_v1.26.bin
```

**boot_merger 的工作原理**
```python
# boot_merger 打包逻辑 (伪代码)
def boot_merger(ini_file):
    # 1. 解析 INI 文件
    chip_name = parse_ini(ini_file, "CHIP_NAME")
    ddr_init = parse_ini(ini_file, "CODE471_OPTION", "Path1")
    miniloader = parse_ini(ini_file, "CODE472_OPTION", "Path1")

    # 2. 读取二进制文件
    ddr_data = read_binary(ddr_init)
    mini_data = read_binary(miniloader)

    # 3. 构建 Loader Header
    header = RkLoaderHeader()
    header.magic = 0x0FF0AA55
    header.chip_type = 0x33333933  # "3399"
    header.component_count = 2

    # DDR Init 组件
    header.component[0] = {
        'load_addr': 0xFF8C0000,  # SRAM 地址
        'size': len(ddr_data),
        'entry': 0xFF8C0000,
        'type': 'DRAM_INIT'
    }

    # Miniloader 组件
    header.component[1] = {
        'load_addr': 0x00000000,  # DDR 地址 (DDR 初始化后)
        'size': len(mini_data),
        'entry': 0x00000000,
        'type': 'MINILOADER'
    }

    # 4. 生成 loader.bin
    with open('loader.bin', 'wb') as f:
        f.write(header.pack())
        f.write(ddr_data)
        f.write(mini_data)

    # 5. 生成 idbloader.img (用于 SD 卡)
    # 添加 Rockchip 魔术数 0x0FF0AA55 在偏移 64 扇区
    create_idbloader_img(header, ddr_data, mini_data)
```

**生成的文件对比**
```bash
$ ls -lh *.bin *.img
-rw-r--r-- 1 user user   82K  loader.bin       # USB 烧录用
-rw-r--r-- 1 user user   82K  idbloader.img    # SD 卡启动用

# idbloader.img 与 loader.bin 的区别
# - idbloader.img 在偏移 64 扇区 (32KB) 处写入
# - 符合 Rockchip BootROM 的 SD 卡启动要求
# - loader.bin 直接通过 USB 传输到 SRAM
```

### 7. BL2 阶段的内存布局

```
RK3399 启动时的内存映射：
┌─────────────────────────────────────┐ 0xFF8C0000
│ SRAM (256KB)                         │
│ ├─ DDR Init 代码 (20KB)  ← TPL     │
│ └─ Miniloader 栈空间 (10KB)         │
├─────────────────────────────────────┤ 0xFF900000
│ PMU SRAM (4KB)                       │
│ └─ BL30 (PMU 固件)                   │
└─────────────────────────────────────┘

DDR 初始化后的内存映射：
┌─────────────────────────────────────┐ 0x00000000
│ Miniloader (60KB)        ← SPL      │
├─────────────────────────────────────┤ 0x00010000
│ BL31 (ATF, 48KB)                    │
├─────────────────────────────────────┤ 0x00040000
│ BL30 (PMU, 45KB)                    │
├─────────────────────────────────────┤ 0x00200000
│ U-Boot (BL33, 1MB)                  │
├─────────────────────────────────────┤ 0x08400000
│ BL32 (OP-TEE, 12MB)                 │
└─────────────────────────────────────┘
```

### 8. 启动时序 (BL2 阶段详细)

```
T=0ms      BL1 (BootROM) 启动
           ├─ CPU 复位向量: 0xFFFF0000
           ├─ 初始化 L1 Cache
           ├─ 设置 SRAM 可用
           └─ 检测启动设备
              ↓
T=5ms      读取 loader.bin 从 eMMC/SD
           ├─ 扇区 64 开始读取 (32KB 偏移)
           ├─ 验证魔术数 0x0FF0AA55
           └─ 加载 DDR Init 到 0xFF8C0000
              ↓
T=10ms     【TPL 阶段】DDR Init 执行
           ├─ 配置 DDR PHY
           ├─ 初始化 LPDDR4 控制器
           ├─ DDR Training (~10ms)  ← 最耗时
           ├─ 内存测试
           └─ 返回 BootROM (DDR_READY 标志)
              ↓
T=20ms     BootROM 加载 Miniloader 到 DDR (0x00000000)
           └─ 跳转到 Miniloader 入口点
              ↓
T=25ms     【SPL 阶段】Miniloader 执行
           ├─ 初始化 UART (1.5Mbps)
           ├─ 初始化 eMMC (HS200 模式)
           ├─ 读取 GPT 分区表
           ├─ 加载 trust.img (BL30/31/32)
           ├─ 加载 uboot.img (BL33)
           └─ 跳转到 BL31 (0x00010000)
              ↓
T=60ms     BL31 (ATF) 开始执行
           【BL2 阶段结束】
```

### 9. 为什么 Rockchip 不用标准 BL2？

**标准 BL2 的问题**
```
ARM 标准 BL2：
❌ 体积较大 (~100KB)，SRAM 放不下
❌ 功能过于复杂，启动速度慢
❌ 需要完整的设备树 (DTB)
❌ 通用方案，未针对 RK3399 优化
```

**Rockchip 方案的优势**
```
loader.bin (DDR Init + Miniloader)：
✅ 体积极小 (82KB)，适合 SRAM
✅ 启动极快 (~60ms 到 ATF)
✅ 高度优化 (专门为 RK3399 设计)
✅ 稳定可靠 (经过量产验证)
```

### 10. 来源与编译

**❌ 完全闭源**

Rockchip 的 DDR Init 和 Miniloader **不开源**：
```bash
# 只能从 rkbin 仓库获取预编译版本
git clone https://github.com/rockchip-linux/rkbin.git
cd rkbin

# DDR Init 固件
ls -lh bin/rk33/rk3399_ddr_*.bin

# Miniloader 固件
ls -lh bin/rk33/rk3399_miniloader_*.bin

# 打包配置
cat RKBOOT/RK3399MINIALL.ini
```

**原因**
- 涉及 Rockchip 专有的 DDR 训练算法
- 包含硬件缺陷的 Workaround
- 商业竞争考虑 (核心技术)

### 11. 是否必需？

**✅ 绝对必需**

没有 BL2 (loader.bin)，系统**无法启动**：
```
❌ DDR 未初始化，无法运行任何代码
❌ 无法从存储设备加载后续固件
❌ ATF (BL31) 无法获得控制权
```

### 12. 使用 U-Boot TPL/SPL 替代 Miniloader (可选)

**开源替代方案**

对于需要完全开源方案的场景，可以用 U-Boot 的 TPL/SPL 替代 Rockchip Miniloader：

```bash
# 1. 配置 U-Boot 启用 TPL/SPL
cd uboot
make rk3399_defconfig
make menuconfig
# 启用:
# - CONFIG_TPL=y
# - CONFIG_SPL=y
# - CONFIG_SPL_ATF=y (加载 ATF 支持)

# 2. 编译
make CROSS_COMPILE=aarch64-linux-gnu- all

# 3. 生成的文件
ls -lh
# - u-boot-tpl.bin     (TPL: DDR 初始化)
# - u-boot-spl.bin     (SPL: 固件加载器)
# - u-boot.bin         (U-Boot Proper)

# 4. 打包 idbloader.img
tools/mkimage -n rk3399 -T rksd -d tpl/u-boot-tpl.bin idbloader.img
cat spl/u-boot-spl.bin >> idbloader.img
```

**对比**

| 特性 | Rockchip loader.bin | U-Boot TPL/SPL |
|------|---------------------|----------------|
| **启动速度** | ⭐⭐⭐⭐⭐ (~60ms) | ⭐⭐⭐ (~100ms) |
| **源码开放** | ❌ 闭源 | ✅ 开源 |
| **可调试性** | ❌ 无法调试 | ✅ 可 GDB 调试 |
| **稳定性** | ⭐⭐⭐⭐⭐ 量产验证 | ⭐⭐⭐⭐ 社区验证 |
| **体积** | 82KB | ~120KB |

---

## BL30 - 电源管理单元固件

### 1. 核心作用

BL30 是运行在 **RK3399 的 Cortex-M0 处理器** 上的固件，专门负责电源管理。

```
RK3399 SoC 架构：
┌─────────────────────────────────────────┐
│  主处理器集群                            │
│  ├─ Cortex-A72 x2 (大核)                │
│  └─ Cortex-A53 x4 (小核)                │
├─────────────────────────────────────────┤
│  PMU (Power Management Unit)            │
│  └─ Cortex-M0 处理器  ← BL30 运行在这里  │
│     - 独立于主 CPU                       │
│     - 低功耗设计                         │
│     - 专用 SRAM                          │
└─────────────────────────────────────────┘
```

### 2. 主要功能

**电源状态管理**
```c
// BL30 处理的电源事件 (伪代码)
void bl30_power_management() {
    while (1) {
        event = wait_for_power_event();

        switch (event) {
            case CPU_SUSPEND:
                // CPU 进入睡眠
                save_cpu_context();
                power_down_voltage_rail();
                enter_low_power_mode();
                break;

            case CPU_RESUME:
                // CPU 唤醒
                power_up_voltage_rail();
                restore_cpu_context();
                send_resume_complete();
                break;

            case DVFS_REQUEST:
                // 动态调频调压
                adjust_cpu_frequency(target_freq);
                adjust_cpu_voltage(target_volt);
                break;

            case THERMAL_EVENT:
                // 温度过高，降频
                throttle_cpu_frequency();
                notify_thermal_driver();
                break;
        }
    }
}
```

**支持的电源操作**
- **CPU 热插拔**: 单独关闭/启动某个 CPU 核心
- **DVFS (动态调频调压)**: 根据负载调整 CPU 频率和电压
- **深度睡眠**: 系统进入 suspend-to-RAM 状态
- **唤醒管理**: 处理各种唤醒源（按键、定时器、网络等）

### 3. 文件信息

**在 TRUST.ini 中的配置**
```ini
[BL30_OPTION]
SEC=0                                    # 非安全模式（PMU 不需要安全权限）
PATH=bin/rk33/rk3399_bl30_v1.00.bin     # 预编译的二进制文件
ADDR=0x00040000                          # 加载到 SRAM 的 0x40000 地址
```

**文件特征**
```bash
$ ls -lh rkbin/bin/rk33/rk3399_bl30_v*.bin
-rw-r--r-- 1 user user  45K  rk3399_bl30_v1.00.bin
-rw-r--r-- 1 user user  48K  rk3399_bl30_v2.22.bin
```

**为什么只有 45KB？**
- Cortex-M0 专用 SRAM 只有 256KB
- 功能单一，不需要复杂的驱动
- 没有操作系统，裸机运行

### 4. 来源与编译

**❌ 无公开源码**
- Rockchip **不开源** BL30 固件
- 只提供预编译的二进制文件（`.bin`）
- 原因：涉及 Rockchip 专有的电源管理算法

**获取方式**
```bash
# 从 rkbin 仓库获取（Rockchip 官方提供）
git clone https://github.com/rockchip-linux/rkbin.git
cd rkbin/bin/rk33/
ls -lh rk3399_bl30_v*.bin

# 多个版本可供选择（选择最新稳定版）
# v1.00 - 早期版本
# v2.22 - 新版本，支持更多电源模式
```

### 5. 是否必需？

**⚠️ 可选，但强烈建议使用**

不包含 BL30 的影响：
```
❌ 无法使用 CPU 热插拔 (echo 0 > /sys/.../cpu1/online 会失败)
❌ DVFS 不工作 (CPU 频率固定，无法动态调整)
❌ suspend/resume 可能失败 (深度睡眠功能缺失)
❌ 温控策略失效 (过热时无法自动降频)
⚠️ 系统能启动，但电源管理功能大幅受限
```

**实际测试**
```bash
# 打包不包含 BL30 的 trust.img
# 修改 TRUST.ini，删除 [BL30_OPTION] 段

# 结果：
# ✅ 系统能正常启动
# ❌ 无法使用 cpufreq
# ❌ suspend 命令失败
```

---

## BL31 - ARM Trusted Firmware

### 1. 核心作用

BL31 是 **ARM Trusted Firmware** 的核心组件，运行在 **EL3 (Exception Level 3)**，拥有系统最高权限。

```
ARM64 异常级别 (Exception Levels):
┌─────────────────────────────────────────┐
│ EL3 (最高权限)           ← BL31 运行在这里│
│ - 控制安全/非安全世界切换                │
│ - 处理 SMC (Secure Monitor Call)        │
│ - 初始化 GIC (中断控制器)                │
│ - 提供 PSCI 接口                         │
├─────────────────────────────────────────┤
│ Secure EL1 (安全世界)    ← BL32 (OP-TEE) │
│ - 运行安全操作系统                       │
│ - 处理密钥、DRM 等敏感操作               │
├─────────────────────────────────────────┤
│ EL2 (Hypervisor)        ← KVM/Xen       │
│ - 虚拟化支持                             │
├─────────────────────────────────────────┤
│ Normal EL1 (非安全世界)  ← Linux Kernel  │
│ - 普通操作系统内核                       │
├─────────────────────────────────────────┤
│ EL0 (用户空间)          ← 应用程序        │
└─────────────────────────────────────────┘
```

### 2. 主要功能

#### (1) PSCI - 电源状态协调接口

```c
// Linux 内核通过 PSCI 调用 BL31 管理 CPU
// 示例：启动 CPU1
smc_call(PSCI_CPU_ON, cpu_id=1, entry_point=0x80000)
  ↓
// BL31 处理 PSCI 调用
int bl31_psci_cpu_on(int cpu_id, uint64_t entry) {
    // 1. 向 BL30 发送电源管理请求
    pmu_power_on_cpu(cpu_id);

    // 2. 配置 CPU 启动地址
    set_cpu_entry_point(cpu_id, entry);

    // 3. 释放 CPU 复位
    release_cpu_reset(cpu_id);

    return PSCI_SUCCESS;
}
```

**PSCI 支持的操作**
- `CPU_ON` - 启动指定 CPU 核心
- `CPU_OFF` - 关闭当前 CPU 核心
- `CPU_SUSPEND` - 挂起 CPU 到低功耗模式
- `SYSTEM_OFF` - 系统关机
- `SYSTEM_RESET` - 系统重启

**实际使用示例**
```bash
# Linux 中的 CPU 热插拔
echo 0 > /sys/devices/system/cpu/cpu1/online  # 调用 PSCI_CPU_OFF
echo 1 > /sys/devices/system/cpu/cpu1/online  # 调用 PSCI_CPU_ON

# 查看 PSCI 版本
cat /sys/firmware/psci_version
# 输出: 1.1
```

#### (2) SMC Handler - 安全监控调用

```c
// 处理从 Normal World 发来的 SMC 调用
uint64_t bl31_smc_handler(uint32_t smc_fid, uint64_t x1,
                          uint64_t x2, uint64_t x3) {
    switch (smc_fid) {
        case PSCI_CPU_ON:
            return psci_cpu_on_handler(x1, x2);

        case PSCI_SYSTEM_RESET:
            return psci_system_reset();

        case TEE_CALL_OPEN_SESSION:
            // 转发给 BL32 (OP-TEE)
            return forward_to_optee(smc_fid, x1, x2, x3);

        default:
            return SMC_UNK;
    }
}
```

#### (3) TrustZone 初始化

```c
// BL31 启动时初始化 TrustZone
void bl31_trustzone_init() {
    // 1. 配置 TZASC (TrustZone Address Space Controller)
    // 将内存划分为安全/非安全区域
    tzasc_configure_region(0x08000000, 0x10000000, SECURE);

    // 2. 配置 TZPC (TrustZone Protection Controller)
    // 保护寄存器和外设
    tzpc_set_peripheral(CRYPTO_ENGINE, SECURE);
    tzpc_set_peripheral(PMU, SECURE);

    // 3. 配置 GIC (Generic Interrupt Controller)
    // 设置中断路由（哪些中断发往安全世界）
    gic_set_interrupt_group(IRQ_CRYPTO, GROUP0_SECURE);
}
```

#### (4) 启动流程管理

```c
// BL31 的主要启动流程
void bl31_main() {
    // 1. 初始化异常向量表
    setup_exception_vectors();

    // 2. 初始化 GIC
    gic_init();

    // 3. 初始化 PSCI
    psci_init();

    // 4. 初始化 TrustZone
    trustzone_init();

    // 5. 加载 BL32 (OP-TEE)
    if (bl32_exists) {
        load_bl32(0x08400000);
        jump_to_bl32();
        // BL32 初始化完成后会返回
    }

    // 6. 跳转到 BL33 (U-Boot)
    jump_to_bl33(0x00200000);

    // 7. BL31 进入常驻模式，等待 SMC 调用
    while (1) {
        wait_for_smc();
    }
}
```

### 3. 文件信息

**在 TRUST.ini 中的配置**
```ini
[BL31_OPTION]
SEC=1                                    # 安全模式（必须是安全）
PATH=bin/rk33/rk3399_bl31_v1.35.elf     # ELF 格式文件
ADDR=0x00010000                          # 加载地址（SRAM）
```

**文件特征**
```bash
$ ls -lh rkbin/bin/rk33/rk3399_bl31_v*.elf
-rw-r--r-- 1 user user  45K  rk3399_bl31_v1.35.elf
-rw-r--r-- 1 user user  48K  rk3399_bl31_v1.42.elf

# 为什么是 ELF 格式？
# - ELF 包含调试信息（符号表、段信息）
# - trust_merger 会自动提取代码段
# - 方便开发者调试和分析
```

**ELF 文件解析**
```bash
# 查看 BL31 ELF 信息
$ arm-linux-gnueabihf-readelf -h rk3399_bl31_v1.35.elf

ELF Header:
  Entry point address:       0x10000      # 入口点
  Program Headers:           3
  Section Headers:           15

# 查看程序段
$ arm-linux-gnueabihf-readelf -l rk3399_bl31_v1.35.elf

Program Headers:
  Type    Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD    0x001000 0x00010000 0x00010000 0x0b000 0x0b000 R E 0x1000
  LOAD    0x00c000 0x0001b000 0x0001b000 0x01000 0x01800 RW  0x1000
```

### 4. 来源与编译

**✅ 完全开源**

BL31 由 **ARM 官方开源** 的 ARM Trusted Firmware 项目提供。

**官方仓库**
```bash
# ARM 官方仓库
git clone https://github.com/ARM-software/arm-trusted-firmware.git
cd arm-trusted-firmware

# Rockchip 维护的分支（包含 RK3399 特定代码）
git clone https://github.com/rockchip-linux/rkbin.git
# Rockchip 提供预编译版本
```

**自行编译 BL31**
```bash
# 1. 安装工具链
sudo apt-get install gcc-aarch64-linux-gnu

# 2. 克隆源码
git clone https://github.com/ARM-software/arm-trusted-firmware.git
cd arm-trusted-firmware

# 3. 编译 RK3399 版本
make CROSS_COMPILE=aarch64-linux-gnu- \
     PLAT=rk3399 \
     DEBUG=1 \
     bl31

# 4. 输出文件
ls -lh build/rk3399/debug/bl31/bl31.elf
# -rw-r--r-- 1 user user  52K  bl31.elf

# 5. 替换 rkbin 中的版本
cp build/rk3399/debug/bl31/bl31.elf \
   ../rkbin/bin/rk33/rk3399_bl31_custom.elf

# 6. 修改 TRUST.ini 使用自定义版本
vim ../rkbin/RKTRUST/RK3399TRUST.ini
# 修改 PATH=bin/rk33/rk3399_bl31_custom.elf
```

**编译选项说明**
```bash
# 调试版本（包含日志输出）
make PLAT=rk3399 DEBUG=1 bl31
# 输出：build/rk3399/debug/bl31/bl31.elf (52KB)

# 发布版本（去除调试信息，更小）
make PLAT=rk3399 DEBUG=0 bl31
# 输出：build/rk3399/release/bl31/bl31.elf (38KB)

# 启用 PSCI 调试日志
make PLAT=rk3399 DEBUG=1 LOG_LEVEL=40 bl31
# LOG_LEVEL: 0=无日志, 20=ERROR, 30=WARN, 40=INFO, 50=VERBOSE
```

### 5. 是否必需？

**✅ 绝对必需**

没有 BL31，系统**无法启动**：

```
启动失败原因：
❌ U-Boot 无法获得控制权（BL31 负责跳转到 U-Boot）
❌ CPU 热插拔完全不可用（PSCI 不存在）
❌ 系统电源管理失效（无法关机/重启）
❌ 无法进入 Secure World（OP-TEE 依赖 BL31）
```

**实际测试**
```bash
# 打包不包含 BL31 的 trust.img
# 修改 TRUST.ini，删除 [BL31_OPTION]

# 结果：系统卡在 Miniloader，永远无法进入 U-Boot
```

---

## BL32 - OP-TEE 安全操作系统

### 1. 核心作用

BL32 是 **OP-TEE (Open Portable Trusted Execution Environment)** 安全操作系统，运行在 **Secure EL1**，提供 **TrustZone** 安全服务。

```
TrustZone 双世界模型：
┌─────────────────────────────────────────┐
│     Normal World (非安全世界)            │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │ Linux Kernel (EL1)                │ │
│  │ - 普通驱动                         │ │
│  │ - 文件系统                         │ │
│  └───────────────────────────────────┘ │
│  ┌───────────────────────────────────┐ │
│  │ User Space (EL0)                  │ │
│  │ - 应用程序                         │ │
│  │ - Chrome, Android Apps            │ │
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘
         ↕ SMC Call (通过 BL31)
┌─────────────────────────────────────────┐
│     Secure World (安全世界)              │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │ OP-TEE OS (BL32, Secure EL1)      │ │
│  │ - 密钥存储                         │ │
│  │ - 加密引擎                         │ │
│  │ - 安全启动验证                     │ │
│  └───────────────────────────────────┘ │
│  ┌───────────────────────────────────┐ │
│  │ Trusted Applications (TA)         │ │
│  │ - DRM 解密                         │ │
│  │ - 指纹识别                         │ │
│  │ - 安全支付                         │ │
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

### 2. 主要功能

#### (1) 安全存储

```c
// Trusted Application 通过 OP-TEE API 存储密钥
TEE_Result store_secret_key(uint8_t* key, size_t key_len) {
    // 创建持久化对象（存储在安全分区）
    TEE_ObjectHandle obj;
    TEE_CreatePersistentObject(
        TEE_STORAGE_PRIVATE,      // 私有存储
        "aes_key",                 // 对象名称
        TEE_DATA_FLAG_ACCESS_WRITE,
        NULL,
        key, key_len,
        &obj
    );

    // 密钥存储在 eMMC 的 RPMB 分区（防篡改）
    // Linux 无法访问此分区
    TEE_CloseObject(obj);
    return TEE_SUCCESS;
}
```

**RPMB (Replay Protected Memory Block)**
```
eMMC 分区布局：
├─ boot0 (4MB)      - Loader 分区
├─ boot1 (4MB)      - 备份 Loader
├─ RPMB (4MB)       - 安全存储 ← OP-TEE 专用，硬件加密
└─ user (剩余)      - 普通数据
```

#### (2) 加密操作

```c
// Trusted Application 执行 AES 加密
TEE_Result aes_encrypt(uint8_t* plaintext, size_t len,
                       uint8_t* ciphertext) {
    TEE_OperationHandle op;
    TEE_ObjectHandle key;

    // 1. 从安全存储加载密钥
    TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE, "aes_key",
                             TEE_DATA_FLAG_ACCESS_READ, &key);

    // 2. 创建加密操作（使用硬件加密引擎）
    TEE_AllocateOperation(&op, TEE_ALG_AES_CBC,
                          TEE_MODE_ENCRYPT, 256);
    TEE_SetOperationKey(op, key);

    // 3. 执行加密（在安全世界，密钥不会泄露）
    TEE_CipherInit(op, iv, sizeof(iv));
    TEE_CipherUpdate(op, plaintext, len, ciphertext, &len);

    // 4. 清理
    TEE_FreeOperation(op);
    TEE_CloseObject(key);
    return TEE_SUCCESS;
}
```

**硬件加密引擎**
- RK3399 有专用的 **Crypto 模块**
- OP-TEE 独占访问此模块（Normal World 无法直接使用）
- 支持 AES、RSA、SHA、HMAC 等算法

#### (3) DRM 内容保护

```c
// Widevine DRM 解密流程
TEE_Result drm_decrypt_video(uint8_t* encrypted_frame,
                              uint8_t* clear_frame) {
    // 1. 验证内容许可
    if (!verify_drm_license()) {
        return TEE_ERROR_ACCESS_DENIED;
    }

    // 2. 从安全存储加载内容密钥
    uint8_t content_key[16];
    load_secure_key("netflix_key", content_key);

    // 3. 解密（密钥从未离开安全世界）
    aes_cbc_decrypt(content_key, encrypted_frame, clear_frame);

    // 4. 直接输出到显示控制器（安全视频路径）
    secure_display_output(clear_frame);

    return TEE_SUCCESS;
}
```

**安全视频路径**
```
加密视频流
  ↓
OP-TEE 解密（密钥在 Secure World）
  ↓
安全内存（Linux 无法访问）
  ↓
直接传输到显示控制器（绕过 Linux）
  ↓
显示器输出

优点：Linux 系统被攻破，也无法窃取解密后的视频
```

#### (4) 安全启动验证

```c
// 验证 Linux Kernel 签名
TEE_Result verify_kernel_signature(uint8_t* kernel_image,
                                    size_t image_size) {
    // 1. 从 eFuse 读取公钥哈希（一次性烧录）
    uint8_t pubkey_hash[32];
    efuse_read(EFUSE_PUBKEY_HASH, pubkey_hash, 32);

    // 2. 验证镜像中的公钥
    uint8_t* embedded_pubkey = extract_pubkey_from_image(kernel_image);
    if (sha256(embedded_pubkey) != pubkey_hash) {
        return TEE_ERROR_SECURITY;  // 公钥被篡改
    }

    // 3. 使用公钥验证镜像签名
    uint8_t* signature = extract_signature_from_image(kernel_image);
    if (!rsa_verify(embedded_pubkey, kernel_image, signature)) {
        return TEE_ERROR_SIGNATURE_INVALID;  // 镜像被篡改
    }

    return TEE_SUCCESS;  // 镜像合法，允许启动
}
```

### 3. 文件信息

**在 TRUST.ini 中的配置**
```ini
[BL32_OPTION]
SEC=1                                    # 安全模式（必须运行在 Secure World）
PATH=bin/rk33/rk3399_bl32_v2.01.bin     # 二进制文件
ADDR=0x08400000                          # 加载地址（DDR）
```

**为什么加载地址是 0x08400000？**
```
RK3399 内存布局（DRAM_BASE = 0x00000000）：
┌─────────────────────────────────────┐ 0x00000000
│ ATF (BL31)       16KB               │
├─────────────────────────────────────┤ 0x00004000
│ 保留区域                            │
├─────────────────────────────────────┤ 0x00200000
│ U-Boot           1MB                │
├─────────────────────────────────────┤ 0x00300000
│ Linux Kernel     128MB              │
├─────────────────────────────────────┤ 0x08000000
│ 保留             4MB                │
├─────────────────────────────────────┤ 0x08400000
│ OP-TEE (BL32)    ~12MB              │ ← BL32 加载位置
│ - OP-TEE OS      2MB                │
│ - Shared Memory  10MB               │
├─────────────────────────────────────┤ 0x09000000
│ Linux 用户空间   剩余内存           │
└─────────────────────────────────────┘

0x08400000 = 132MB 偏移
- 足够高，避免与 Kernel 冲突
- 预留 10MB 共享内存（Linux ↔ OP-TEE 通信）
```

**文件大小**
```bash
$ ls -lh rkbin/bin/rk33/rk3399_bl32_v*.bin
-rw-r--r-- 1 user user  1.2M  rk3399_bl32_v1.26.bin
-rw-r--r-- 1 user user  1.8M  rk3399_bl32_v2.01.bin

# 为什么这么大？
# - 包含完整的 OP-TEE OS（类似一个微型 Linux）
# - 内置多个 Trusted Applications (TA)
# - 包含加密库（mbedTLS）
```

### 4. 来源与编译

**✅ 完全开源**

OP-TEE 是 **Linaro 主导的开源项目**。

**官方仓库**
```bash
# OP-TEE 官方仓库
git clone https://github.com/OP-TEE/optee_os.git
cd optee_os

# Rockchip 维护的分支
git clone https://github.com/rockchip-linux/optee_os.git -b rk3399
```

**自行编译 BL32 (OP-TEE)**
```bash
# 1. 安装工具链
sudo apt-get install gcc-aarch64-linux-gnu

# 2. 克隆源码
git clone https://github.com/OP-TEE/optee_os.git
cd optee_os

# 3. 编译 RK3399 版本
make CROSS_COMPILE=aarch64-linux-gnu- \
     CROSS_COMPILE_core=aarch64-linux-gnu- \
     CROSS_COMPILE_ta_arm64=aarch64-linux-gnu- \
     PLATFORM=rockchip-rk3399 \
     CFG_ARM64_core=y \
     CFG_TEE_CORE_LOG_LEVEL=3

# 4. 输出文件
ls -lh out/arm-plat-rockchip/core/tee.bin
# -rw-r--r-- 1 user user  1.5M  tee.bin

# 5. 替换 rkbin 中的版本
cp out/arm-plat-rockchip/core/tee.bin \
   ../rkbin/bin/rk33/rk3399_bl32_custom.bin

# 6. 修改 TRUST.ini
vim ../rkbin/RKTRUST/RK3399TRUST.ini
# 修改 PATH=bin/rk33/rk3399_bl32_custom.bin
```

**编译 Trusted Application (TA)**
```bash
# 编写自定义 TA（如 AES 加密服务）
mkdir my_ta
cd my_ta

# 创建 TA 源码（参考 OP-TEE 示例）
cat > my_ta.c << 'EOF'
#include <tee_internal_api.h>

TEE_Result TA_InvokeCommandEntryPoint(
    void* session, uint32_t cmd_id,
    uint32_t param_types, TEE_Param params[4]) {

    switch (cmd_id) {
        case CMD_AES_ENCRYPT:
            return do_aes_encrypt(params);
        default:
            return TEE_ERROR_BAD_PARAMETERS;
    }
}
EOF

# 编译 TA
make CROSS_COMPILE_ta_arm64=aarch64-linux-gnu- ta

# 部署 TA 到设备
cp out/*.ta /lib/optee_armtz/
```

### 5. 是否必需？

**⚠️ 可选，取决于使用场景**

**不需要 BL32 的场景**
```
✅ 嵌入式开发板（无 DRM 需求）
✅ 服务器（不需要安全功能）
✅ 调试阶段（简化启动流程）
```

**必须有 BL32 的场景**
```
❌ Android 设备（Widevine DRM 必需）
❌ 需要安全存储（密钥管理）
❌ 支付终端（安全元素）
❌ 工业控制（安全启动）
```

**禁用 BL32 的影响**
```bash
# 打包不包含 BL32 的 trust.img
export TRUST_PACK_IGNORE_BL32="--ignore-bl32"
./make.sh trust

# 结果：
✅ 系统正常启动
✅ Linux 完全可用
❌ 无法播放 Netflix/Prime Video (DRM 失败)
❌ 无法使用 /dev/tee* 设备
❌ Android KeyStore 失效
```

**实际文件大小对比**
```bash
# 包含 BL32
$ ls -lh trust.img
-rw-r--r-- 1 user user  2.1M  trust.img

# 不包含 BL32
$ ls -lh trust.img
-rw-r--r-- 1 user user  512K  trust.img
```

---

## BL33 - U-Boot Bootloader

### 1. 核心作用

BL33 是 **Non-Secure Bootloader**，通常是 **U-Boot** 或 **UEFI**，运行在 **Normal World**。

```
BL33 在启动流程中的位置：
BL31 (ATF) → BL32 (OP-TEE) → BL33 (U-Boot) → Linux Kernel
                                     ↑
                              你在这里！
```

### 2. 主要功能

- 初始化外设（USB、网络、显示器）
- 加载 Linux 内核和设备树
- 提供启动菜单（选择不同内核/系统）
- 支持网络启动（TFTP、PXE）
- 固件升级和恢复

### 3. 为什么称为 BL33？

根据 ARM 规范：
- **BL33** 是 ATF 启动的最后一个组件
- 运行在 **Non-Secure EL2/EL1**
- 由 **BL31** 负责跳转到 BL33

### 4. 来源

**✅ 完全开源**
- U-Boot 官方仓库：https://github.com/u-boot/u-boot
- Rockchip 定制版本：https://github.com/rockchip-linux/u-boot

### 5. 在 TRUST.ini 中的体现

```ini
[BL33_OPTION]
SEC=0                    # 非安全模式

# 注意：BL33 的实际文件（u-boot.bin）不在 trust.img 中
# 它被单独打包为 uboot.img
```

---

## 完整启动流程

### 启动时序图

```
时间轴：系统上电 → Linux 启动

T=0ms      BootROM (BL1) 开始执行
           ├─ 从 eMMC/SD 读取 loader.bin
           └─ 加载 DDR Init 到 SRAM
              ↓
T=20ms     DDR Init 运行
           ├─ 初始化 LPDDR4 内存
           └─ 返回 BootROM
              ↓
T=40ms     BootROM 加载 Miniloader 到 DDR
           └─ Miniloader 初始化 eMMC（高速模式）
              ↓
T=60ms     Miniloader 加载 trust.img 到 DDR
           ├─ 解析 trust.img 头部
           ├─ 加载 BL30 到 0x00040000
           ├─ 加载 BL31 到 0x00010000
           └─ 加载 BL32 到 0x08400000
              ↓
T=80ms     跳转到 BL31 (ATF) [EL3]
           ├─ 初始化 GIC (中断控制器)
           ├─ 初始化 TrustZone (安全/非安全分界)
           ├─ 初始化 PSCI (电源管理接口)
           └─ 跳转到 BL32
              ↓
T=100ms    BL32 (OP-TEE) 初始化 [Secure EL1]
           ├─ 初始化安全内存
           ├─ 加载 Trusted Applications (TA)
           ├─ 初始化 RPMB 安全存储
           └─ 返回 BL31
              ↓
T=120ms    BL31 跳转到 BL33 (U-Boot) [Normal EL2]
           └─ Miniloader 加载 uboot.img 到 DDR
              ↓
T=140ms    U-Boot 启动
           ├─ 初始化串口、USB、网络
           ├─ 读取环境变量
           ├─ 加载 Linux 内核到 0x02080000
           ├─ 加载 设备树 到 0x08300000
           └─ bootm 0x02080000 - 0x08300000
              ↓
T=200ms    Linux Kernel 启动 [Normal EL1]
           ├─ 解压内核
           ├─ 初始化内存管理
           ├─ 挂载根文件系统
           └─ 启动 init
              ↓
T=5000ms   用户空间 (systemd/OpenRC) [EL0]
           └─ 登录提示符
```

### BL 组件交互图

```
┌──────────────────────────────────────────────┐
│  BootROM (BL1) - 芯片固化                     │
│  - 加载 Miniloader                           │
└──────────────────┬───────────────────────────┘
                   ↓
┌──────────────────────────────────────────────┐
│  Miniloader - 加载所有固件到内存              │
│  - 加载 BL30/BL31/BL32 (trust.img)          │
│  - 加载 BL33 (uboot.img)                    │
└──────────────────┬───────────────────────────┘
                   ↓
         ┌─────────┴─────────┐
         ↓                   ↓
┌────────────────┐    ┌──────────────┐
│ BL30 (PMU)     │    │ BL31 (ATF)   │ [EL3]
│ - 电源管理      │←───│ - TrustZone  │
│ - DVFS         │    │ - PSCI       │
└────────────────┘    └──────┬───────┘
                             ↓
                      ┌──────────────┐
                      │ BL32 (TEE)   │ [Secure EL1]
                      │ - DRM        │
                      │ - 密钥管理    │
                      └──────┬───────┘
                             ↓
                      ┌──────────────┐
                      │ BL33 (U-Boot)│ [Normal EL2]
                      │ - 加载内核    │
                      └──────┬───────┘
                             ↓
                      ┌──────────────┐
                      │ Linux Kernel │ [Normal EL1]
                      └──────────────┘
```

---

## 打包方式详解

### trust.img 的生成过程

```bash
# 1. 准备 BL 组件文件
rkbin/
├─ bin/rk33/
│  ├─ rk3399_bl30_v2.22.bin     # BL30: 45KB
│  ├─ rk3399_bl31_v1.35.elf     # BL31: 48KB (ELF 格式)
│  └─ rk3399_bl32_v2.01.bin     # BL32: 1.8MB

# 2. 配置文件 (TRUST.ini) 指定组件
RKTRUST/RK3399TRUST.ini:
[BL30_OPTION]
PATH=bin/rk33/rk3399_bl30_v2.22.bin
ADDR=0x00040000

[BL31_OPTION]
PATH=bin/rk33/rk3399_bl31_v1.35.elf
ADDR=0x00010000

[BL32_OPTION]
PATH=bin/rk33/rk3399_bl32_v2.01.bin
ADDR=0x08400000

# 3. trust_merger 工具打包
${RKTOOLS}/trust_merger \
    --replace tools/rk_tools/ ./ \
    RKTRUST/RK3399TRUST.ini

# 4. 生成 trust.img
trust.img (2.1MB):
┌────────────────────────────────┐
│ Rockchip Header (2KB)          │
│ - Magic: 0x0FF0AA55            │
│ - Component count: 3           │
│ - Component 0: BL30 info       │
│ - Component 1: BL31 info       │
│ - Component 2: BL32 info       │
├────────────────────────────────┤
│ BL30 binary (45KB)             │
├────────────────────────────────┤
│ BL31 binary (48KB)             │
│ (从 ELF 提取代码段)             │
├────────────────────────────────┤
│ BL32 binary (1.8MB)            │
├────────────────────────────────┤
│ Padding (对齐到 4KB)            │
└────────────────────────────────┘
```

### trust_merger 的工作原理

```python
# 伪代码展示打包逻辑
def trust_merger(ini_file):
    # 1. 解析 INI 文件
    bl30 = parse_ini_section(ini_file, "BL30_OPTION")
    bl31 = parse_ini_section(ini_file, "BL31_OPTION")
    bl32 = parse_ini_section(ini_file, "BL32_OPTION")

    # 2. 读取二进制文件
    bl30_data = read_binary(bl30.path)

    # 3. 特殊处理 BL31 (ELF 格式)
    if is_elf(bl31.path):
        bl31_data = extract_elf_code_section(bl31.path)
        bl31_entry = extract_elf_entry_point(bl31.path)

    bl32_data = read_binary(bl32.path)

    # 4. 构建 Trust Header
    header = RkTrustHeader()
    header.magic = 0x0FF0AA55
    header.num_components = 3

    # BL30 组件信息
    header.component[0] = {
        'load_addr': bl30.addr,
        'size': len(bl30_data),
        'entry': bl30.addr,
        'offset': 0x800
    }

    # BL31 组件信息
    header.component[1] = {
        'load_addr': bl31.addr,
        'size': len(bl31_data),
        'entry': bl31_entry,  # 从 ELF 提取
        'offset': 0x800 + align(len(bl30_data), 512)
    }

    # BL32 组件信息
    header.component[2] = {
        'load_addr': bl32.addr,
        'size': len(bl32_data),
        'entry': bl32.addr,
        'offset': previous_offset + align(len(bl31_data), 512)
    }

    # 5. 计算 SHA256 哈希
    all_data = bl30_data + bl31_data + bl32_data
    header.hash = sha256(all_data)

    # 6. 写入输出文件
    with open('trust.img', 'wb') as f:
        f.write(header.pack())
        f.write(bl30_data)
        f.write(bl31_data)
        f.write(bl32_data)
```

---

## 源码来源与编译

### 完整对比表

| 组件 | 源码状态 | 官方仓库 | Rockchip 仓库 | 编译难度 |
|------|---------|---------|--------------|---------|
| **BL30** | ❌ 闭源 | 无 | rkbin (仅二进制) | ❌ 无法编译 |
| **BL31** | ✅ 开源 | ARM-software/arm-trusted-firmware | rockchip-linux/rkbin (预编译) | ⭐ 简单 |
| **BL32** | ✅ 开源 | OP-TEE/optee_os | rockchip-linux/optee_os | ⭐⭐ 中等 |
| **BL33** | ✅ 开源 | u-boot/u-boot | rockchip-linux/u-boot | ⭐⭐⭐ 复杂 |

### BL31 编译实战

```bash
# 克隆 ARM 官方仓库
git clone https://github.com/ARM-software/arm-trusted-firmware.git
cd arm-trusted-firmware

# 查看支持的平台
ls plat/rockchip/
# 输出: common rk3288 rk3328 rk3399 rk3568 ...

# 编译 RK3399 BL31
make CROSS_COMPILE=aarch64-linux-gnu- \
     PLAT=rk3399 \
     DEBUG=0 \
     bl31

# 输出文件
build/rk3399/release/bl31/bl31.elf

# 查看符号表
aarch64-linux-gnu-nm build/rk3399/release/bl31/bl31.elf | grep psci
# 输出:
# 0000000000010540 T psci_cpu_on
# 0000000000010680 T psci_cpu_off
# 00000000000107c0 T psci_system_reset
```

### BL32 编译实战

```bash
# 克隆 OP-TEE 官方仓库
git clone https://github.com/OP-TEE/optee_os.git
cd optee_os

# 查看支持的平台
ls core/arch/arm/plat-rockchip/
# 输出: conf.mk platform_config.h platform_rk322x.c platform_rk3399.c

# 编译 RK3399 OP-TEE
export CROSS_COMPILE=aarch64-linux-gnu-
make PLATFORM=rockchip-rk3399 \
     CFG_ARM64_core=y \
     CFG_TEE_CORE_LOG_LEVEL=2

# 输出文件
out/arm-plat-rockchip/core/tee.bin         # BL32 主文件
out/arm-plat-rockchip/core/tee.elf         # ELF 格式（带符号）
out/arm-plat-rockchip/core/tee-pager.bin   # 分页版本

# 查看编译信息
cat out/arm-plat-rockchip/core/tee.map | grep -A 5 "Memory map"
```

### 替换自定义 BL 组件

```bash
# 1. 编译自定义 BL31
cd arm-trusted-firmware
make PLAT=rk3399 DEBUG=1 bl31

# 2. 复制到 rkbin
cp build/rk3399/debug/bl31/bl31.elf \
   ../rkbin/bin/rk33/rk3399_bl31_custom.elf

# 3. 修改 TRUST.ini
cd ../rkbin
vim RKTRUST/RK3399TRUST_CUSTOM.ini

[BL31_OPTION]
PATH=bin/rk33/rk3399_bl31_custom.elf   # 使用自定义版本
ADDR=0x00010000

# 4. 打包 trust.img
cd ../uboot
export FILE=../rkbin/RKTRUST/RK3399TRUST_CUSTOM.ini
./make.sh trust

# 5. 烧录测试
sudo rkdeveloptool wl trust trust.img
sudo rkdeveloptool rd   # 重启设备
```

---

## 实战：自定义 BL 组件

### 实战 1: 启用 BL31 调试日志

```bash
# 1. 编译带调试日志的 BL31
cd arm-trusted-firmware
make PLAT=rk3399 \
     DEBUG=1 \
     LOG_LEVEL=40 \
     bl31

# LOG_LEVEL:
#   0  - 无日志
#   10 - ERROR
#   20 - NOTICE
#   30 - WARNING
#   40 - INFO
#   50 - VERBOSE

# 2. 替换并打包
cp build/rk3399/debug/bl31/bl31.elf \
   ../rkbin/bin/rk33/rk3399_bl31_v1.35.elf

cd ../uboot
./make.sh trust

# 3. 烧录并查看串口日志
sudo rkdeveloptool wl trust trust.img
sudo rkdeveloptool rd

# 串口输出（波特率 1500000）:
# NOTICE:  BL31: v2.5(debug):v2.5-dirty
# NOTICE:  BL31: Built : 10:30:00, Jan 15 2024
# INFO:    GICv3 with legacy support detected.
# INFO:    ARM GICv3 driver initialized in EL3
# INFO:    BL31: Initializing runtime services
# INFO:    BL31: cortex_a72: CPU workaround for 859971 was applied
# INFO:    BL31: cortex_a53: CPU workaround for 855873 was applied
# INFO:    BL31: Preparing for EL3 exit to normal world
```

### 实战 2: 禁用 BL32 减少启动时间

```bash
# 1. 打包不包含 BL32 的 trust.img
cd uboot
export TRUST_PACK_IGNORE_BL32="--ignore-bl32"
./make.sh trust

# 2. 查看文件大小差异
ls -lh trust.img
# 不含 BL32: 512KB
# 含 BL32:   2.1MB

# 3. 对比启动时间
# 含 BL32:   ~200ms 到 U-Boot
# 无 BL32:   ~120ms 到 U-Boot
# 节省:      80ms
```

### 实战 3: 添加自定义 Trusted Application

```bash
# 1. 创建 TA 项目
mkdir my_secure_storage_ta
cd my_secure_storage_ta

# 2. 编写 TA 代码
cat > secure_storage_ta.c << 'EOF'
#include <tee_internal_api.h>

#define CMD_STORE_SECRET  1
#define CMD_LOAD_SECRET   2

TEE_Result TA_InvokeCommandEntryPoint(
    void* session, uint32_t cmd,
    uint32_t types, TEE_Param params[4]) {

    switch (cmd) {
        case CMD_STORE_SECRET:
            return store_secret(params[0].memref.buffer,
                                params[0].memref.size);
        case CMD_LOAD_SECRET:
            return load_secret(params[0].memref.buffer,
                               &params[0].memref.size);
        default:
            return TEE_ERROR_BAD_PARAMETERS;
    }
}

TEE_Result store_secret(void* data, size_t len) {
    TEE_ObjectHandle obj;
    TEE_Result res;

    res = TEE_CreatePersistentObject(
        TEE_STORAGE_PRIVATE,
        "my_secret", strlen("my_secret"),
        TEE_DATA_FLAG_ACCESS_WRITE,
        NULL,
        data, len,
        &obj);

    TEE_CloseObject(obj);
    return res;
}
EOF

# 3. 编译 TA
export TA_DEV_KIT_DIR=../optee_os/out/arm-plat-rockchip/export-ta_arm64
make CROSS_COMPILE=aarch64-linux-gnu- ta

# 4. 部署到设备
cp out/*.ta /lib/optee_armtz/
```

### 实战 4: 验证 PSCI 功能

```bash
# 1. 确认 PSCI 版本
cat /sys/firmware/psci_version
# 输出: 1.1

# 2. 测试 CPU 热插拔
echo 0 > /sys/devices/system/cpu/cpu1/online
echo "CPU1 已关闭"
lscpu | grep "On-line CPU"
# 输出: On-line CPU(s) list: 0,2,3,4,5

echo 1 > /sys/devices/system/cpu/cpu1/online
echo "CPU1 已启动"
lscpu | grep "On-line CPU"
# 输出: On-line CPU(s) list: 0-5

# 3. 查看 PSCI 方法
dmesg | grep -i psci
# [    0.000000] psci: probing for conduit method from DT.
# [    0.000000] psci: PSCIv1.1 detected in firmware.
# [    0.000000] psci: Using standard PSCI v0.2 function IDs
```

---

## 总结对比表

### 功能对比

| 特性 | BL2 | BL30 | BL31 | BL32 |
|------|------|------|------|------|
| **运行环境** | SRAM → DDR | Cortex-M0 MCU | EL3 (最高权限) | Secure EL1 |
| **主要功能** | DDR初始化/固件加载 | 电源管理 | TrustZone/PSCI | 安全服务/DRM |
| **是否必需** | 必需 | 可选(推荐) | 必需 | 可选 |
| **源码状态** | 闭源 (Rockchip) | 闭源 | 开源 (ARM) | 开源 (Linaro) |
| **文件大小** | 82KB (loader.bin) | 45KB | 48KB | 1.8MB |
| **启动顺序** | 0 (最早) | 3 (与 BL31 并行) | 1 | 2 |
| **依赖关系** | 无依赖 | 被 BL31 调用 | 依赖 BL2 加载 | 依赖 BL31 |
| **实现方式** | DDR Init + Miniloader | PMU 固件 | ATF | OP-TEE |

### 使用建议

**场景 1: 开发调试**
```
✅ BL2 (必需，loader.bin)
✅ BL31 (必需)
❌ BL32 (禁用，加快启动)
❌ BL30 (禁用，简化调试)
```

**场景 2: 嵌入式产品**
```
✅ BL2 (必需，loader.bin)
✅ BL31 (必需)
✅ BL30 (启用，支持 DVFS)
⚠️ BL32 (按需，是否需要安全功能)
```

**场景 3: Android 设备**
```
✅ BL2 (必需，loader.bin)
✅ BL31 (必需)
✅ BL30 (必需，电源管理)
✅ BL32 (必需，Widevine DRM)
```

**场景 4: 完全开源方案**
```
✅ BL2 (使用 U-Boot TPL/SPL 替代 Rockchip Miniloader)
✅ BL31 (自行编译 ARM Trusted Firmware)
✅ BL30 (可选，仅预编译版本)
⚠️ BL32 (可选，自行编译 OP-TEE)
```

---

## 参考资源

**官方文档**
- ARM Trusted Firmware: https://trustedfirmware-a.readthedocs.io/
- OP-TEE Documentation: https://optee.readthedocs.io/
- Rockchip Wiki: http://opensource.rock-chips.com/

**源码仓库**
- ATF: https://github.com/ARM-software/arm-trusted-firmware
- OP-TEE: https://github.com/OP-TEE/optee_os
- rkbin: https://github.com/rockchip-linux/rkbin

**调试工具**
- UART 串口：波特率 1500000
- rkdeveloptool：固件烧录工具
- GDB + OpenOCD：BL31/BL32 调试

---

**文档版本**: v1.2
**最后更新**: 2025-12-22
**更新内容**:
- v1.1: 新增 BL2 (SPL/TPL) 章节详解
- v1.2: 修正 TPL/SPL 命名混淆说明
**作者**: Claude Sonnet 4.5
