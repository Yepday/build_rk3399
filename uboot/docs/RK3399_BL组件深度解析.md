# Rockchip RK3399 BL 组件深度解析

## 目录
1. [BL 命名规范与 ARM Trusted Firmware 架构](#bl-命名规范)
2. [BL30 - 电源管理单元固件](#bl30-电源管理单元固件)
3. [BL31 - ARM Trusted Firmware](#bl31-arm-trusted-firmware)
4. [BL32 - OP-TEE 安全操作系统](#bl32-op-tee-安全操作系统)
5. [BL33 - U-Boot Bootloader](#bl33-u-boot-bootloader)
6. [完整启动流程与 BL 组件交互](#完整启动流程)
7. [打包方式详解](#打包方式详解)
8. [源码来源与编译](#源码来源与编译)
9. [实战：自定义 BL 组件](#实战自定义-bl-组件)

---

## BL 命名规范

### ARM Trusted Firmware 标准

BL (Boot Loader) 是 **ARM Trusted Firmware** 定义的启动阶段命名规范：

```
BL1  → Boot ROM (固化在芯片中，厂商提供)
BL2  → Trusted Boot Firmware (可选，很少使用) (loader.bin = DDR Init + Miniloader)
BL30 → 芯片厂商自定义组件 (Rockchip: PMU 固件)
BL31 → EL3 Runtime Firmware (ARM Trusted Firmware)
BL32 → Secure-EL1 Payload (OP-TEE / Trusty)
BL33 → Non-Secure Bootloader (U-Boot / UEFI)
```

### Rockchip 的 BL 定义

| 组件 | ARM 标准名称 | Rockchip 实现 | 运行环境 | 是否必需 |
|------|-------------|--------------|---------|---------|
| **BL1** | Boot ROM | BootROM (芯片内部) | 芯片内部 ROM | ✅ 必需 |
| **BL2** | Trusted Boot FW | (未使用) | - | ❌ 不使用 (loader.bin = DDR Init + Miniloader)|
| **BL30** | SCP Firmware | PMU 固件 | Cortex-M0 MCU | ⚠️ 可选 |
| **BL31** | EL3 Runtime | ATF (ARM Trusted Firmware) | EL3 (最高权限) | ✅ 必需 |
| **BL32** | Secure Payload | OP-TEE OS | Secure EL1 | ⚠️ 可选 |
| **BL33** | Non-Secure BL | U-Boot | Normal EL2/EL1 | ✅ 必需 |

---

## BL30 - 电源管理单元固件

### 1. 核心作用

BL30 是运行在 **RK3399 的 Cortex-M0 处理器** 上的固件，专门负责电源管理。

```
RK3399 SoC 架构：
┌─────────────────────────────────────────┐
│  主处理器集群                            │
│  ├─ Cortex-A72 x2 (大核)                │
│  └─ Cortex-A53 x4 (小核)                │
├─────────────────────────────────────────┤
│  PMU (Power Management Unit)            │
│  └─ Cortex-M0 处理器  ← BL30 运行在这里  │
│     - 独立于主 CPU                       │
│     - 低功耗设计                         │
│     - 专用 SRAM                          │
└─────────────────────────────────────────┘
```

### 2. 主要功能

**电源状态管理**
```c
// BL30 处理的电源事件 (伪代码)
void bl30_power_management() {
    while (1) {
        event = wait_for_power_event();

        switch (event) {
            case CPU_SUSPEND:
                // CPU 进入睡眠
                save_cpu_context();
                power_down_voltage_rail();
                enter_low_power_mode();
                break;

            case CPU_RESUME:
                // CPU 唤醒
                power_up_voltage_rail();
                restore_cpu_context();
                send_resume_complete();
                break;

            case DVFS_REQUEST:
                // 动态调频调压
                adjust_cpu_frequency(target_freq);
                adjust_cpu_voltage(target_volt);
                break;

            case THERMAL_EVENT:
                // 温度过高，降频
                throttle_cpu_frequency();
                notify_thermal_driver();
                break;
        }
    }
}
```

**支持的电源操作**
- **CPU 热插拔**: 单独关闭/启动某个 CPU 核心
- **DVFS (动态调频调压)**: 根据负载调整 CPU 频率和电压
- **深度睡眠**: 系统进入 suspend-to-RAM 状态
- **唤醒管理**: 处理各种唤醒源（按键、定时器、网络等）

### 3. 文件信息

**在 TRUST.ini 中的配置**
```ini
[BL30_OPTION]
SEC=0                                    # 非安全模式（PMU 不需要安全权限）
PATH=bin/rk33/rk3399_bl30_v1.00.bin     # 预编译的二进制文件
ADDR=0x00040000                          # 加载到 SRAM 的 0x40000 地址
```

**文件特征**
```bash
$ ls -lh rkbin/bin/rk33/rk3399_bl30_v*.bin
-rw-r--r-- 1 user user  45K  rk3399_bl30_v1.00.bin
-rw-r--r-- 1 user user  48K  rk3399_bl30_v2.22.bin
```

**为什么只有 45KB？**
- Cortex-M0 专用 SRAM 只有 256KB
- 功能单一，不需要复杂的驱动
- 没有操作系统，裸机运行

### 4. 来源与编译

**❌ 无公开源码**
- Rockchip **不开源** BL30 固件
- 只提供预编译的二进制文件（`.bin`）
- 原因：涉及 Rockchip 专有的电源管理算法

**获取方式**
```bash
# 从 rkbin 仓库获取（Rockchip 官方提供）
git clone https://github.com/rockchip-linux/rkbin.git
cd rkbin/bin/rk33/
ls -lh rk3399_bl30_v*.bin

# 多个版本可供选择（选择最新稳定版）
# v1.00 - 早期版本
# v2.22 - 新版本，支持更多电源模式
```

### 5. 是否必需？

**⚠️ 可选，但强烈建议使用**

不包含 BL30 的影响：
```
❌ 无法使用 CPU 热插拔 (echo 0 > /sys/.../cpu1/online 会失败)
❌ DVFS 不工作 (CPU 频率固定，无法动态调整)
❌ suspend/resume 可能失败 (深度睡眠功能缺失)
❌ 温控策略失效 (过热时无法自动降频)
⚠️ 系统能启动，但电源管理功能大幅受限
```

**实际测试**
```bash
# 打包不包含 BL30 的 trust.img
# 修改 TRUST.ini，删除 [BL30_OPTION] 段

# 结果：
# ✅ 系统能正常启动
# ❌ 无法使用 cpufreq
# ❌ suspend 命令失败
```

---

## BL31 - ARM Trusted Firmware

### 1. 核心作用

BL31 是 **ARM Trusted Firmware** 的核心组件，运行在 **EL3 (Exception Level 3)**，拥有系统最高权限。

```
ARM64 异常级别 (Exception Levels):
┌─────────────────────────────────────────┐
│ EL3 (最高权限)           ← BL31 运行在这里│
│ - 控制安全/非安全世界切换                │
│ - 处理 SMC (Secure Monitor Call)        │
│ - 初始化 GIC (中断控制器)                │
│ - 提供 PSCI 接口                         │
├─────────────────────────────────────────┤
│ Secure EL1 (安全世界)    ← BL32 (OP-TEE) │
│ - 运行安全操作系统                       │
│ - 处理密钥、DRM 等敏感操作               │
├─────────────────────────────────────────┤
│ EL2 (Hypervisor)        ← KVM/Xen       │
│ - 虚拟化支持                             │
├─────────────────────────────────────────┤
│ Normal EL1 (非安全世界)  ← Linux Kernel  │
│ - 普通操作系统内核                       │
├─────────────────────────────────────────┤
│ EL0 (用户空间)          ← 应用程序        │
└─────────────────────────────────────────┘
```

### 2. 主要功能

#### (1) PSCI - 电源状态协调接口

```c
// Linux 内核通过 PSCI 调用 BL31 管理 CPU
// 示例：启动 CPU1
smc_call(PSCI_CPU_ON, cpu_id=1, entry_point=0x80000)
  ↓
// BL31 处理 PSCI 调用
int bl31_psci_cpu_on(int cpu_id, uint64_t entry) {
    // 1. 向 BL30 发送电源管理请求
    pmu_power_on_cpu(cpu_id);

    // 2. 配置 CPU 启动地址
    set_cpu_entry_point(cpu_id, entry);

    // 3. 释放 CPU 复位
    release_cpu_reset(cpu_id);

    return PSCI_SUCCESS;
}
```

**PSCI 支持的操作**
- `CPU_ON` - 启动指定 CPU 核心
- `CPU_OFF` - 关闭当前 CPU 核心
- `CPU_SUSPEND` - 挂起 CPU 到低功耗模式
- `SYSTEM_OFF` - 系统关机
- `SYSTEM_RESET` - 系统重启

**实际使用示例**
```bash
# Linux 中的 CPU 热插拔
echo 0 > /sys/devices/system/cpu/cpu1/online  # 调用 PSCI_CPU_OFF
echo 1 > /sys/devices/system/cpu/cpu1/online  # 调用 PSCI_CPU_ON

# 查看 PSCI 版本
cat /sys/firmware/psci_version
# 输出: 1.1
```

#### (2) SMC Handler - 安全监控调用

```c
// 处理从 Normal World 发来的 SMC 调用
uint64_t bl31_smc_handler(uint32_t smc_fid, uint64_t x1,
                          uint64_t x2, uint64_t x3) {
    switch (smc_fid) {
        case PSCI_CPU_ON:
            return psci_cpu_on_handler(x1, x2);

        case PSCI_SYSTEM_RESET:
            return psci_system_reset();

        case TEE_CALL_OPEN_SESSION:
            // 转发给 BL32 (OP-TEE)
            return forward_to_optee(smc_fid, x1, x2, x3);

        default:
            return SMC_UNK;
    }
}
```

#### (3) TrustZone 初始化

```c
// BL31 启动时初始化 TrustZone
void bl31_trustzone_init() {
    // 1. 配置 TZASC (TrustZone Address Space Controller)
    // 将内存划分为安全/非安全区域
    tzasc_configure_region(0x08000000, 0x10000000, SECURE);

    // 2. 配置 TZPC (TrustZone Protection Controller)
    // 保护寄存器和外设
    tzpc_set_peripheral(CRYPTO_ENGINE, SECURE);
    tzpc_set_peripheral(PMU, SECURE);

    // 3. 配置 GIC (Generic Interrupt Controller)
    // 设置中断路由（哪些中断发往安全世界）
    gic_set_interrupt_group(IRQ_CRYPTO, GROUP0_SECURE);
}
```

#### (4) 启动流程管理

```c
// BL31 的主要启动流程
void bl31_main() {
    // 1. 初始化异常向量表
    setup_exception_vectors();

    // 2. 初始化 GIC
    gic_init();

    // 3. 初始化 PSCI
    psci_init();

    // 4. 初始化 TrustZone
    trustzone_init();

    // 5. 加载 BL32 (OP-TEE)
    if (bl32_exists) {
        load_bl32(0x08400000);
        jump_to_bl32();
        // BL32 初始化完成后会返回
    }

    // 6. 跳转到 BL33 (U-Boot)
    jump_to_bl33(0x00200000);

    // 7. BL31 进入常驻模式，等待 SMC 调用
    while (1) {
        wait_for_smc();
    }
}
```

### 3. 文件信息

**在 TRUST.ini 中的配置**
```ini
[BL31_OPTION]
SEC=1                                    # 安全模式（必须是安全）
PATH=bin/rk33/rk3399_bl31_v1.35.elf     # ELF 格式文件
ADDR=0x00010000                          # 加载地址（SRAM）
```

**文件特征**
```bash
$ ls -lh rkbin/bin/rk33/rk3399_bl31_v*.elf
-rw-r--r-- 1 user user  45K  rk3399_bl31_v1.35.elf
-rw-r--r-- 1 user user  48K  rk3399_bl31_v1.42.elf

# 为什么是 ELF 格式？
# - ELF 包含调试信息（符号表、段信息）
# - trust_merger 会自动提取代码段
# - 方便开发者调试和分析
```

**ELF 文件解析**
```bash
# 查看 BL31 ELF 信息
$ arm-linux-gnueabihf-readelf -h rk3399_bl31_v1.35.elf

ELF Header:
  Entry point address:       0x10000      # 入口点
  Program Headers:           3
  Section Headers:           15

# 查看程序段
$ arm-linux-gnueabihf-readelf -l rk3399_bl31_v1.35.elf

Program Headers:
  Type    Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD    0x001000 0x00010000 0x00010000 0x0b000 0x0b000 R E 0x1000
  LOAD    0x00c000 0x0001b000 0x0001b000 0x01000 0x01800 RW  0x1000
```

### 4. 来源与编译

**✅ 完全开源**

BL31 由 **ARM 官方开源** 的 ARM Trusted Firmware 项目提供。

**官方仓库**
```bash
# ARM 官方仓库
git clone https://github.com/ARM-software/arm-trusted-firmware.git
cd arm-trusted-firmware

# Rockchip 维护的分支（包含 RK3399 特定代码）
git clone https://github.com/rockchip-linux/rkbin.git
# Rockchip 提供预编译版本
```

**自行编译 BL31**
```bash
# 1. 安装工具链
sudo apt-get install gcc-aarch64-linux-gnu

# 2. 克隆源码
git clone https://github.com/ARM-software/arm-trusted-firmware.git
cd arm-trusted-firmware

# 3. 编译 RK3399 版本
make CROSS_COMPILE=aarch64-linux-gnu- \
     PLAT=rk3399 \
     DEBUG=1 \
     bl31

# 4. 输出文件
ls -lh build/rk3399/debug/bl31/bl31.elf
# -rw-r--r-- 1 user user  52K  bl31.elf

# 5. 替换 rkbin 中的版本
cp build/rk3399/debug/bl31/bl31.elf \
   ../rkbin/bin/rk33/rk3399_bl31_custom.elf

# 6. 修改 TRUST.ini 使用自定义版本
vim ../rkbin/RKTRUST/RK3399TRUST.ini
# 修改 PATH=bin/rk33/rk3399_bl31_custom.elf
```

**编译选项说明**
```bash
# 调试版本（包含日志输出）
make PLAT=rk3399 DEBUG=1 bl31
# 输出：build/rk3399/debug/bl31/bl31.elf (52KB)

# 发布版本（去除调试信息，更小）
make PLAT=rk3399 DEBUG=0 bl31
# 输出：build/rk3399/release/bl31/bl31.elf (38KB)

# 启用 PSCI 调试日志
make PLAT=rk3399 DEBUG=1 LOG_LEVEL=40 bl31
# LOG_LEVEL: 0=无日志, 20=ERROR, 30=WARN, 40=INFO, 50=VERBOSE
```

### 5. 是否必需？

**✅ 绝对必需**

没有 BL31，系统**无法启动**：

```
启动失败原因：
❌ U-Boot 无法获得控制权（BL31 负责跳转到 U-Boot）
❌ CPU 热插拔完全不可用（PSCI 不存在）
❌ 系统电源管理失效（无法关机/重启）
❌ 无法进入 Secure World（OP-TEE 依赖 BL31）
```

**实际测试**
```bash
# 打包不包含 BL31 的 trust.img
# 修改 TRUST.ini，删除 [BL31_OPTION]

# 结果：系统卡在 Miniloader，永远无法进入 U-Boot
```

---

## BL32 - OP-TEE 安全操作系统

### 1. 核心作用

BL32 是 **OP-TEE (Open Portable Trusted Execution Environment)** 安全操作系统，运行在 **Secure EL1**，提供 **TrustZone** 安全服务。

```
TrustZone 双世界模型：
┌─────────────────────────────────────────┐
│     Normal World (非安全世界)            │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │ Linux Kernel (EL1)                │ │
│  │ - 普通驱动                         │ │
│  │ - 文件系统                         │ │
│  └───────────────────────────────────┘ │
│  ┌───────────────────────────────────┐ │
│  │ User Space (EL0)                  │ │
│  │ - 应用程序                         │ │
│  │ - Chrome, Android Apps            │ │
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘
         ↕ SMC Call (通过 BL31)
┌─────────────────────────────────────────┐
│     Secure World (安全世界)              │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │ OP-TEE OS (BL32, Secure EL1)      │ │
│  │ - 密钥存储                         │ │
│  │ - 加密引擎                         │ │
│  │ - 安全启动验证                     │ │
│  └───────────────────────────────────┘ │
│  ┌───────────────────────────────────┐ │
│  │ Trusted Applications (TA)         │ │
│  │ - DRM 解密                         │ │
│  │ - 指纹识别                         │ │
│  │ - 安全支付                         │ │
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

### 2. 主要功能

#### (1) 安全存储

```c
// Trusted Application 通过 OP-TEE API 存储密钥
TEE_Result store_secret_key(uint8_t* key, size_t key_len) {
    // 创建持久化对象（存储在安全分区）
    TEE_ObjectHandle obj;
    TEE_CreatePersistentObject(
        TEE_STORAGE_PRIVATE,      // 私有存储
        "aes_key",                 // 对象名称
        TEE_DATA_FLAG_ACCESS_WRITE,
        NULL,
        key, key_len,
        &obj
    );

    // 密钥存储在 eMMC 的 RPMB 分区（防篡改）
    // Linux 无法访问此分区
    TEE_CloseObject(obj);
    return TEE_SUCCESS;
}
```

**RPMB (Replay Protected Memory Block)**
```
eMMC 分区布局：
├─ boot0 (4MB)      - Loader 分区
├─ boot1 (4MB)      - 备份 Loader
├─ RPMB (4MB)       - 安全存储 ← OP-TEE 专用，硬件加密
└─ user (剩余)      - 普通数据
```

#### (2) 加密操作

```c
// Trusted Application 执行 AES 加密
TEE_Result aes_encrypt(uint8_t* plaintext, size_t len,
                       uint8_t* ciphertext) {
    TEE_OperationHandle op;
    TEE_ObjectHandle key;

    // 1. 从安全存储加载密钥
    TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE, "aes_key",
                             TEE_DATA_FLAG_ACCESS_READ, &key);

    // 2. 创建加密操作（使用硬件加密引擎）
    TEE_AllocateOperation(&op, TEE_ALG_AES_CBC,
                          TEE_MODE_ENCRYPT, 256);
    TEE_SetOperationKey(op, key);

    // 3. 执行加密（在安全世界，密钥不会泄露）
    TEE_CipherInit(op, iv, sizeof(iv));
    TEE_CipherUpdate(op, plaintext, len, ciphertext, &len);

    // 4. 清理
    TEE_FreeOperation(op);
    TEE_CloseObject(key);
    return TEE_SUCCESS;
}
```

**硬件加密引擎**
- RK3399 有专用的 **Crypto 模块**
- OP-TEE 独占访问此模块（Normal World 无法直接使用）
- 支持 AES、RSA、SHA、HMAC 等算法

#### (3) DRM 内容保护

```c
// Widevine DRM 解密流程
TEE_Result drm_decrypt_video(uint8_t* encrypted_frame,
                              uint8_t* clear_frame) {
    // 1. 验证内容许可
    if (!verify_drm_license()) {
        return TEE_ERROR_ACCESS_DENIED;
    }

    // 2. 从安全存储加载内容密钥
    uint8_t content_key[16];
    load_secure_key("netflix_key", content_key);

    // 3. 解密（密钥从未离开安全世界）
    aes_cbc_decrypt(content_key, encrypted_frame, clear_frame);

    // 4. 直接输出到显示控制器（安全视频路径）
    secure_display_output(clear_frame);

    return TEE_SUCCESS;
}
```

**安全视频路径**
```
加密视频流
  ↓
OP-TEE 解密（密钥在 Secure World）
  ↓
安全内存（Linux 无法访问）
  ↓
直接传输到显示控制器（绕过 Linux）
  ↓
显示器输出

优点：Linux 系统被攻破，也无法窃取解密后的视频
```

#### (4) 安全启动验证

```c
// 验证 Linux Kernel 签名
TEE_Result verify_kernel_signature(uint8_t* kernel_image,
                                    size_t image_size) {
    // 1. 从 eFuse 读取公钥哈希（一次性烧录）
    uint8_t pubkey_hash[32];
    efuse_read(EFUSE_PUBKEY_HASH, pubkey_hash, 32);

    // 2. 验证镜像中的公钥
    uint8_t* embedded_pubkey = extract_pubkey_from_image(kernel_image);
    if (sha256(embedded_pubkey) != pubkey_hash) {
        return TEE_ERROR_SECURITY;  // 公钥被篡改
    }

    // 3. 使用公钥验证镜像签名
    uint8_t* signature = extract_signature_from_image(kernel_image);
    if (!rsa_verify(embedded_pubkey, kernel_image, signature)) {
        return TEE_ERROR_SIGNATURE_INVALID;  // 镜像被篡改
    }

    return TEE_SUCCESS;  // 镜像合法，允许启动
}
```

### 3. 文件信息

**在 TRUST.ini 中的配置**
```ini
[BL32_OPTION]
SEC=1                                    # 安全模式（必须运行在 Secure World）
PATH=bin/rk33/rk3399_bl32_v2.01.bin     # 二进制文件
ADDR=0x08400000                          # 加载地址（DDR）
```

**为什么加载地址是 0x08400000？**
```
RK3399 内存布局（DRAM_BASE = 0x00000000）：
┌─────────────────────────────────────┐ 0x00000000
│ ATF (BL31)       16KB               │
├─────────────────────────────────────┤ 0x00004000
│ 保留区域                            │
├─────────────────────────────────────┤ 0x00200000
│ U-Boot           1MB                │
├─────────────────────────────────────┤ 0x00300000
│ Linux Kernel     128MB              │
├─────────────────────────────────────┤ 0x08000000
│ 保留             4MB                │
├─────────────────────────────────────┤ 0x08400000
│ OP-TEE (BL32)    ~12MB              │ ← BL32 加载位置
│ - OP-TEE OS      2MB                │
│ - Shared Memory  10MB               │
├─────────────────────────────────────┤ 0x09000000
│ Linux 用户空间   剩余内存           │
└─────────────────────────────────────┘

0x08400000 = 132MB 偏移
- 足够高，避免与 Kernel 冲突
- 预留 10MB 共享内存（Linux ↔ OP-TEE 通信）
```

**文件大小**
```bash
$ ls -lh rkbin/bin/rk33/rk3399_bl32_v*.bin
-rw-r--r-- 1 user user  1.2M  rk3399_bl32_v1.26.bin
-rw-r--r-- 1 user user  1.8M  rk3399_bl32_v2.01.bin

# 为什么这么大？
# - 包含完整的 OP-TEE OS（类似一个微型 Linux）
# - 内置多个 Trusted Applications (TA)
# - 包含加密库（mbedTLS）
```

### 4. 来源与编译

**✅ 完全开源**

OP-TEE 是 **Linaro 主导的开源项目**。

**官方仓库**
```bash
# OP-TEE 官方仓库
git clone https://github.com/OP-TEE/optee_os.git
cd optee_os

# Rockchip 维护的分支
git clone https://github.com/rockchip-linux/optee_os.git -b rk3399
```

**自行编译 BL32 (OP-TEE)**
```bash
# 1. 安装工具链
sudo apt-get install gcc-aarch64-linux-gnu

# 2. 克隆源码
git clone https://github.com/OP-TEE/optee_os.git
cd optee_os

# 3. 编译 RK3399 版本
make CROSS_COMPILE=aarch64-linux-gnu- \
     CROSS_COMPILE_core=aarch64-linux-gnu- \
     CROSS_COMPILE_ta_arm64=aarch64-linux-gnu- \
     PLATFORM=rockchip-rk3399 \
     CFG_ARM64_core=y \
     CFG_TEE_CORE_LOG_LEVEL=3

# 4. 输出文件
ls -lh out/arm-plat-rockchip/core/tee.bin
# -rw-r--r-- 1 user user  1.5M  tee.bin

# 5. 替换 rkbin 中的版本
cp out/arm-plat-rockchip/core/tee.bin \
   ../rkbin/bin/rk33/rk3399_bl32_custom.bin

# 6. 修改 TRUST.ini
vim ../rkbin/RKTRUST/RK3399TRUST.ini
# 修改 PATH=bin/rk33/rk3399_bl32_custom.bin
```

**编译 Trusted Application (TA)**
```bash
# 编写自定义 TA（如 AES 加密服务）
mkdir my_ta
cd my_ta

# 创建 TA 源码（参考 OP-TEE 示例）
cat > my_ta.c << 'EOF'
#include <tee_internal_api.h>

TEE_Result TA_InvokeCommandEntryPoint(
    void* session, uint32_t cmd_id,
    uint32_t param_types, TEE_Param params[4]) {

    switch (cmd_id) {
        case CMD_AES_ENCRYPT:
            return do_aes_encrypt(params);
        default:
            return TEE_ERROR_BAD_PARAMETERS;
    }
}
EOF

# 编译 TA
make CROSS_COMPILE_ta_arm64=aarch64-linux-gnu- ta

# 部署 TA 到设备
cp out/*.ta /lib/optee_armtz/
```

### 5. 是否必需？

**⚠️ 可选，取决于使用场景**

**不需要 BL32 的场景**
```
✅ 嵌入式开发板（无 DRM 需求）
✅ 服务器（不需要安全功能）
✅ 调试阶段（简化启动流程）
```

**必须有 BL32 的场景**
```
❌ Android 设备（Widevine DRM 必需）
❌ 需要安全存储（密钥管理）
❌ 支付终端（安全元素）
❌ 工业控制（安全启动）
```

**禁用 BL32 的影响**
```bash
# 打包不包含 BL32 的 trust.img
export TRUST_PACK_IGNORE_BL32="--ignore-bl32"
./make.sh trust

# 结果：
✅ 系统正常启动
✅ Linux 完全可用
❌ 无法播放 Netflix/Prime Video (DRM 失败)
❌ 无法使用 /dev/tee* 设备
❌ Android KeyStore 失效
```

**实际文件大小对比**
```bash
# 包含 BL32
$ ls -lh trust.img
-rw-r--r-- 1 user user  2.1M  trust.img

# 不包含 BL32
$ ls -lh trust.img
-rw-r--r-- 1 user user  512K  trust.img
```

---

## BL33 - U-Boot Bootloader

### 1. 核心作用

BL33 是 **Non-Secure Bootloader**，通常是 **U-Boot** 或 **UEFI**，运行在 **Normal World**。

```
BL33 在启动流程中的位置：
BL31 (ATF) → BL32 (OP-TEE) → BL33 (U-Boot) → Linux Kernel
                                     ↑
                              你在这里！
```

### 2. 主要功能

- 初始化外设（USB、网络、显示器）
- 加载 Linux 内核和设备树
- 提供启动菜单（选择不同内核/系统）
- 支持网络启动（TFTP、PXE）
- 固件升级和恢复

### 3. 为什么称为 BL33？

根据 ARM 规范：
- **BL33** 是 ATF 启动的最后一个组件
- 运行在 **Non-Secure EL2/EL1**
- 由 **BL31** 负责跳转到 BL33

### 4. 来源

**✅ 完全开源**
- U-Boot 官方仓库：https://github.com/u-boot/u-boot
- Rockchip 定制版本：https://github.com/rockchip-linux/u-boot

### 5. 在 TRUST.ini 中的体现

```ini
[BL33_OPTION]
SEC=0                    # 非安全模式

# 注意：BL33 的实际文件（u-boot.bin）不在 trust.img 中
# 它被单独打包为 uboot.img
```

---

## 完整启动流程

### 启动时序图

```
时间轴：系统上电 → Linux 启动

T=0ms      BootROM (BL1) 开始执行
           ├─ 从 eMMC/SD 读取 loader.bin
           └─ 加载 DDR Init 到 SRAM
              ↓
T=20ms     DDR Init 运行
           ├─ 初始化 LPDDR4 内存
           └─ 返回 BootROM
              ↓
T=40ms     BootROM 加载 Miniloader 到 DDR
           └─ Miniloader 初始化 eMMC（高速模式）
              ↓
T=60ms     Miniloader 加载 trust.img 到 DDR
           ├─ 解析 trust.img 头部
           ├─ 加载 BL30 到 0x00040000
           ├─ 加载 BL31 到 0x00010000
           └─ 加载 BL32 到 0x08400000
              ↓
T=80ms     跳转到 BL31 (ATF) [EL3]
           ├─ 初始化 GIC (中断控制器)
           ├─ 初始化 TrustZone (安全/非安全分界)
           ├─ 初始化 PSCI (电源管理接口)
           └─ 跳转到 BL32
              ↓
T=100ms    BL32 (OP-TEE) 初始化 [Secure EL1]
           ├─ 初始化安全内存
           ├─ 加载 Trusted Applications (TA)
           ├─ 初始化 RPMB 安全存储
           └─ 返回 BL31
              ↓
T=120ms    BL31 跳转到 BL33 (U-Boot) [Normal EL2]
           └─ Miniloader 加载 uboot.img 到 DDR
              ↓
T=140ms    U-Boot 启动
           ├─ 初始化串口、USB、网络
           ├─ 读取环境变量
           ├─ 加载 Linux 内核到 0x02080000
           ├─ 加载 设备树 到 0x08300000
           └─ bootm 0x02080000 - 0x08300000
              ↓
T=200ms    Linux Kernel 启动 [Normal EL1]
           ├─ 解压内核
           ├─ 初始化内存管理
           ├─ 挂载根文件系统
           └─ 启动 init
              ↓
T=5000ms   用户空间 (systemd/OpenRC) [EL0]
           └─ 登录提示符
```

### BL 组件交互图

```
┌──────────────────────────────────────────────┐
│  BootROM (BL1) - 芯片固化                     │
│  - 加载 Miniloader                           │
└──────────────────┬───────────────────────────┘
                   ↓
┌──────────────────────────────────────────────┐
│  Miniloader - 加载所有固件到内存              │
│  - 加载 BL30/BL31/BL32 (trust.img)          │
│  - 加载 BL33 (uboot.img)                    │
└──────────────────┬───────────────────────────┘
                   ↓
         ┌─────────┴─────────┐
         ↓                   ↓
┌────────────────┐    ┌──────────────┐
│ BL30 (PMU)     │    │ BL31 (ATF)   │ [EL3]
│ - 电源管理      │←───│ - TrustZone  │
│ - DVFS         │    │ - PSCI       │
└────────────────┘    └──────┬───────┘
                             ↓
                      ┌──────────────┐
                      │ BL32 (TEE)   │ [Secure EL1]
                      │ - DRM        │
                      │ - 密钥管理    │
                      └──────┬───────┘
                             ↓
                      ┌──────────────┐
                      │ BL33 (U-Boot)│ [Normal EL2]
                      │ - 加载内核    │
                      └──────┬───────┘
                             ↓
                      ┌──────────────┐
                      │ Linux Kernel │ [Normal EL1]
                      └──────────────┘
```

---

## 打包方式详解

### trust.img 的生成过程

```bash
# 1. 准备 BL 组件文件
rkbin/
├─ bin/rk33/
│  ├─ rk3399_bl30_v2.22.bin     # BL30: 45KB
│  ├─ rk3399_bl31_v1.35.elf     # BL31: 48KB (ELF 格式)
│  └─ rk3399_bl32_v2.01.bin     # BL32: 1.8MB

# 2. 配置文件 (TRUST.ini) 指定组件
RKTRUST/RK3399TRUST.ini:
[BL30_OPTION]
PATH=bin/rk33/rk3399_bl30_v2.22.bin
ADDR=0x00040000

[BL31_OPTION]
PATH=bin/rk33/rk3399_bl31_v1.35.elf
ADDR=0x00010000

[BL32_OPTION]
PATH=bin/rk33/rk3399_bl32_v2.01.bin
ADDR=0x08400000

# 3. trust_merger 工具打包
${RKTOOLS}/trust_merger \
    --replace tools/rk_tools/ ./ \
    RKTRUST/RK3399TRUST.ini

# 4. 生成 trust.img
trust.img (2.1MB):
┌────────────────────────────────┐
│ Rockchip Header (2KB)          │
│ - Magic: 0x0FF0AA55            │
│ - Component count: 3           │
│ - Component 0: BL30 info       │
│ - Component 1: BL31 info       │
│ - Component 2: BL32 info       │
├────────────────────────────────┤
│ BL30 binary (45KB)             │
├────────────────────────────────┤
│ BL31 binary (48KB)             │
│ (从 ELF 提取代码段)             │
├────────────────────────────────┤
│ BL32 binary (1.8MB)            │
├────────────────────────────────┤
│ Padding (对齐到 4KB)            │
└────────────────────────────────┘
```

### trust_merger 的工作原理

```python
# 伪代码展示打包逻辑
def trust_merger(ini_file):
    # 1. 解析 INI 文件
    bl30 = parse_ini_section(ini_file, "BL30_OPTION")
    bl31 = parse_ini_section(ini_file, "BL31_OPTION")
    bl32 = parse_ini_section(ini_file, "BL32_OPTION")

    # 2. 读取二进制文件
    bl30_data = read_binary(bl30.path)

    # 3. 特殊处理 BL31 (ELF 格式)
    if is_elf(bl31.path):
        bl31_data = extract_elf_code_section(bl31.path)
        bl31_entry = extract_elf_entry_point(bl31.path)

    bl32_data = read_binary(bl32.path)

    # 4. 构建 Trust Header
    header = RkTrustHeader()
    header.magic = 0x0FF0AA55
    header.num_components = 3

    # BL30 组件信息
    header.component[0] = {
        'load_addr': bl30.addr,
        'size': len(bl30_data),
        'entry': bl30.addr,
        'offset': 0x800
    }

    # BL31 组件信息
    header.component[1] = {
        'load_addr': bl31.addr,
        'size': len(bl31_data),
        'entry': bl31_entry,  # 从 ELF 提取
        'offset': 0x800 + align(len(bl30_data), 512)
    }

    # BL32 组件信息
    header.component[2] = {
        'load_addr': bl32.addr,
        'size': len(bl32_data),
        'entry': bl32.addr,
        'offset': previous_offset + align(len(bl31_data), 512)
    }

    # 5. 计算 SHA256 哈希
    all_data = bl30_data + bl31_data + bl32_data
    header.hash = sha256(all_data)

    # 6. 写入输出文件
    with open('trust.img', 'wb') as f:
        f.write(header.pack())
        f.write(bl30_data)
        f.write(bl31_data)
        f.write(bl32_data)
```

---

## 源码来源与编译

### 完整对比表

| 组件 | 源码状态 | 官方仓库 | Rockchip 仓库 | 编译难度 |
|------|---------|---------|--------------|---------|
| **BL30** | ❌ 闭源 | 无 | rkbin (仅二进制) | ❌ 无法编译 |
| **BL31** | ✅ 开源 | ARM-software/arm-trusted-firmware | rockchip-linux/rkbin (预编译) | ⭐ 简单 |
| **BL32** | ✅ 开源 | OP-TEE/optee_os | rockchip-linux/optee_os | ⭐⭐ 中等 |
| **BL33** | ✅ 开源 | u-boot/u-boot | rockchip-linux/u-boot | ⭐⭐⭐ 复杂 |

### BL31 编译实战

```bash
# 克隆 ARM 官方仓库
git clone https://github.com/ARM-software/arm-trusted-firmware.git
cd arm-trusted-firmware

# 查看支持的平台
ls plat/rockchip/
# 输出: common rk3288 rk3328 rk3399 rk3568 ...

# 编译 RK3399 BL31
make CROSS_COMPILE=aarch64-linux-gnu- \
     PLAT=rk3399 \
     DEBUG=0 \
     bl31

# 输出文件
build/rk3399/release/bl31/bl31.elf

# 查看符号表
aarch64-linux-gnu-nm build/rk3399/release/bl31/bl31.elf | grep psci
# 输出:
# 0000000000010540 T psci_cpu_on
# 0000000000010680 T psci_cpu_off
# 00000000000107c0 T psci_system_reset
```

### BL32 编译实战

```bash
# 克隆 OP-TEE 官方仓库
git clone https://github.com/OP-TEE/optee_os.git
cd optee_os

# 查看支持的平台
ls core/arch/arm/plat-rockchip/
# 输出: conf.mk platform_config.h platform_rk322x.c platform_rk3399.c

# 编译 RK3399 OP-TEE
export CROSS_COMPILE=aarch64-linux-gnu-
make PLATFORM=rockchip-rk3399 \
     CFG_ARM64_core=y \
     CFG_TEE_CORE_LOG_LEVEL=2

# 输出文件
out/arm-plat-rockchip/core/tee.bin         # BL32 主文件
out/arm-plat-rockchip/core/tee.elf         # ELF 格式（带符号）
out/arm-plat-rockchip/core/tee-pager.bin   # 分页版本

# 查看编译信息
cat out/arm-plat-rockchip/core/tee.map | grep -A 5 "Memory map"
```

### 替换自定义 BL 组件

```bash
# 1. 编译自定义 BL31
cd arm-trusted-firmware
make PLAT=rk3399 DEBUG=1 bl31

# 2. 复制到 rkbin
cp build/rk3399/debug/bl31/bl31.elf \
   ../rkbin/bin/rk33/rk3399_bl31_custom.elf

# 3. 修改 TRUST.ini
cd ../rkbin
vim RKTRUST/RK3399TRUST_CUSTOM.ini

[BL31_OPTION]
PATH=bin/rk33/rk3399_bl31_custom.elf   # 使用自定义版本
ADDR=0x00010000

# 4. 打包 trust.img
cd ../uboot
export FILE=../rkbin/RKTRUST/RK3399TRUST_CUSTOM.ini
./make.sh trust

# 5. 烧录测试
sudo rkdeveloptool wl trust trust.img
sudo rkdeveloptool rd   # 重启设备
```

---

## 实战：自定义 BL 组件

### 实战 1: 启用 BL31 调试日志

```bash
# 1. 编译带调试日志的 BL31
cd arm-trusted-firmware
make PLAT=rk3399 \
     DEBUG=1 \
     LOG_LEVEL=40 \
     bl31

# LOG_LEVEL:
#   0  - 无日志
#   10 - ERROR
#   20 - NOTICE
#   30 - WARNING
#   40 - INFO
#   50 - VERBOSE

# 2. 替换并打包
cp build/rk3399/debug/bl31/bl31.elf \
   ../rkbin/bin/rk33/rk3399_bl31_v1.35.elf

cd ../uboot
./make.sh trust

# 3. 烧录并查看串口日志
sudo rkdeveloptool wl trust trust.img
sudo rkdeveloptool rd

# 串口输出（波特率 1500000）:
# NOTICE:  BL31: v2.5(debug):v2.5-dirty
# NOTICE:  BL31: Built : 10:30:00, Jan 15 2024
# INFO:    GICv3 with legacy support detected.
# INFO:    ARM GICv3 driver initialized in EL3
# INFO:    BL31: Initializing runtime services
# INFO:    BL31: cortex_a72: CPU workaround for 859971 was applied
# INFO:    BL31: cortex_a53: CPU workaround for 855873 was applied
# INFO:    BL31: Preparing for EL3 exit to normal world
```

### 实战 2: 禁用 BL32 减少启动时间

```bash
# 1. 打包不包含 BL32 的 trust.img
cd uboot
export TRUST_PACK_IGNORE_BL32="--ignore-bl32"
./make.sh trust

# 2. 查看文件大小差异
ls -lh trust.img
# 不含 BL32: 512KB
# 含 BL32:   2.1MB

# 3. 对比启动时间
# 含 BL32:   ~200ms 到 U-Boot
# 无 BL32:   ~120ms 到 U-Boot
# 节省:      80ms
```

### 实战 3: 添加自定义 Trusted Application

```bash
# 1. 创建 TA 项目
mkdir my_secure_storage_ta
cd my_secure_storage_ta

# 2. 编写 TA 代码
cat > secure_storage_ta.c << 'EOF'
#include <tee_internal_api.h>

#define CMD_STORE_SECRET  1
#define CMD_LOAD_SECRET   2

TEE_Result TA_InvokeCommandEntryPoint(
    void* session, uint32_t cmd,
    uint32_t types, TEE_Param params[4]) {

    switch (cmd) {
        case CMD_STORE_SECRET:
            return store_secret(params[0].memref.buffer,
                                params[0].memref.size);
        case CMD_LOAD_SECRET:
            return load_secret(params[0].memref.buffer,
                               &params[0].memref.size);
        default:
            return TEE_ERROR_BAD_PARAMETERS;
    }
}

TEE_Result store_secret(void* data, size_t len) {
    TEE_ObjectHandle obj;
    TEE_Result res;

    res = TEE_CreatePersistentObject(
        TEE_STORAGE_PRIVATE,
        "my_secret", strlen("my_secret"),
        TEE_DATA_FLAG_ACCESS_WRITE,
        NULL,
        data, len,
        &obj);

    TEE_CloseObject(obj);
    return res;
}
EOF

# 3. 编译 TA
export TA_DEV_KIT_DIR=../optee_os/out/arm-plat-rockchip/export-ta_arm64
make CROSS_COMPILE=aarch64-linux-gnu- ta

# 4. 部署到设备
cp out/*.ta /lib/optee_armtz/
```

### 实战 4: 验证 PSCI 功能

```bash
# 1. 确认 PSCI 版本
cat /sys/firmware/psci_version
# 输出: 1.1

# 2. 测试 CPU 热插拔
echo 0 > /sys/devices/system/cpu/cpu1/online
echo "CPU1 已关闭"
lscpu | grep "On-line CPU"
# 输出: On-line CPU(s) list: 0,2,3,4,5

echo 1 > /sys/devices/system/cpu/cpu1/online
echo "CPU1 已启动"
lscpu | grep "On-line CPU"
# 输出: On-line CPU(s) list: 0-5

# 3. 查看 PSCI 方法
dmesg | grep -i psci
# [    0.000000] psci: probing for conduit method from DT.
# [    0.000000] psci: PSCIv1.1 detected in firmware.
# [    0.000000] psci: Using standard PSCI v0.2 function IDs
```

---

## 总结对比表

### 功能对比

| 特性 | BL30 | BL31 | BL32 |
|------|------|------|------|
| **运行环境** | Cortex-M0 MCU | EL3 (最高权限) | Secure EL1 |
| **主要功能** | 电源管理 | TrustZone/PSCI | 安全服务/DRM |
| **是否必需** | 可选(推荐) | 必需 | 可选 |
| **源码状态** | 闭源 | 开源 (ARM) | 开源 (Linaro) |
| **文件大小** | 45KB | 48KB | 1.8MB |
| **启动顺序** | 3 (与 BL31 并行) | 1 | 2 |
| **依赖关系** | 被 BL31 调用 | 无依赖 | 依赖 BL31 |

### 使用建议

**场景 1: 开发调试**
```
✅ BL31 (必需)
❌ BL32 (禁用，加快启动)
❌ BL30 (禁用，简化调试)
```

**场景 2: 嵌入式产品**
```
✅ BL31 (必需)
✅ BL30 (启用，支持 DVFS)
⚠️ BL32 (按需，是否需要安全功能)
```

**场景 3: Android 设备**
```
✅ BL31 (必需)
✅ BL30 (必需，电源管理)
✅ BL32 (必需，Widevine DRM)
```

---

## 参考资源

**官方文档**
- ARM Trusted Firmware: https://trustedfirmware-a.readthedocs.io/
- OP-TEE Documentation: https://optee.readthedocs.io/
- Rockchip Wiki: http://opensource.rock-chips.com/

**源码仓库**
- ATF: https://github.com/ARM-software/arm-trusted-firmware
- OP-TEE: https://github.com/OP-TEE/optee_os
- rkbin: https://github.com/rockchip-linux/rkbin

**调试工具**
- UART 串口：波特率 1500000
- rkdeveloptool：固件烧录工具
- GDB + OpenOCD：BL31/BL32 调试

---

**文档版本**: v1.0
**最后更新**: 2025-12-22
**作者**: Claude Sonnet 4.5
