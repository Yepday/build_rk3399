# U-Boot 链接脚本与启动流程深度解析

## 概述

本教程深入解析为什么嵌入式系统（特别是U-Boot）必须使用链接脚本（lds），以及RK3399的底层启动机制。涵盖从CPU硬件复位到U-Boot执行的完整流程。

---

## 一、为什么需要链接脚本？

### 1.1 编译器默认链接的局限性

**编译器的默认链接行为是为通用操作系统设计的**，它假设：
- 代码运行在有操作系统的环境中
- 内存布局由操作系统管理
- 程序加载地址可以随机（ASLR）
- 有虚拟内存支持

但 **U-Boot 是裸机固件**，运行在没有操作系统的环境中。

### 1.2 U-Boot 必须使用链接脚本的原因

#### 原因1：精确的内存地址控制

RK3399 的 BootROM 会将 U-Boot 加载到特定物理地址（如 `0x00200000`），链接脚本必须确保：

```lds
MEMORY
{
    sdram : ORIGIN = 0x00200000, LENGTH = 0x00100000
}

SECTIONS
{
    . = 0x00200000;
    .text : { *(.text) }     /* 代码段必须在这个地址 */
    .data : { *(.data) }
}
```

如果地址不匹配，CPU 跳转到错误地址会导致启动失败。

#### 原因2：启动代码必须在最前面

U-Boot 的入口点（`_start`）必须位于镜像的最开始：

```lds
SECTIONS
{
    .text : {
        arch/arm/cpu/armv8/start.o (.text*)  /* 必须第一个 */
        *(.text*)                             /* 其他代码 */
    }
}
```

编译器默认链接会按字母顺序或链接顺序排列，无法保证启动代码在最前。

#### 原因3：特殊段的放置

U-Boot 需要特殊的段布局：

- `.vectors` - 异常向量表必须在固定地址
- `.rodata` - 只读数据需要与代码分离
- `.bss` - 未初始化数据在运行时才分配，不占镜像空间
- `.rel.dyn` - 重定位表用于位置无关代码

```lds
.bss : {
    __bss_start = .;
    *(.bss*)
    __bss_end = .;
}
```

代码通过 `__bss_start` 和 `__bss_end` 符号来清零 BSS 段。

#### 原因4：内存区域隔离

RK3399 有不同的内存区域：

```lds
MEMORY
{
    sram : ORIGIN = 0xFF8C0000, LENGTH = 192K   /* 片上SRAM */
    dram : ORIGIN = 0x00200000, LENGTH = 4G     /* DDR */
}

SECTIONS
{
    .sram : { *(.sram_code) } > sram   /* 早期启动代码在SRAM */
    .text : { *(.text) } > dram         /* 主代码在DDR */
}
```

编译器不知道硬件内存布局。

#### 原因5：镜像大小限制

Rockchip BootROM 对 U-Boot 镜像大小有严格限制（通常 2MB），链接脚本可以检测：

```lds
ASSERT(__image_end - __image_start < 0x200000, "U-Boot image too large")
```

#### 原因6：符号导出供 C 代码使用

链接脚本定义的符号可以在 C 代码中引用：

```c
// C 代码中
extern char __bss_start[];
extern char __bss_end[];

void clear_bss(void) {
    memset(__bss_start, 0, __bss_end - __bss_start);
}
```

### 1.3 对比：应用程序 vs U-Boot

| 特性 | Linux应用程序 | U-Boot固件 |
|------|---------------|------------|
| 加载地址 | 操作系统决定 | **硬件固定** |
| 内存管理 | 虚拟内存 | **物理内存直接映射** |
| 启动入口 | `main()` | **_start (固定偏移)** |
| 段顺序 | 无关紧要 | **严格顺序要求** |
| BSS初始化 | 操作系统负责 | **自己清零** |
| 重定位 | 动态链接器处理 | **自己重定位** |

### 1.4 实际例子：RK3399 链接脚本

查看 RK3399 的 U-Boot 链接脚本:

```bash
cat arch/arm/cpu/armv8/u-boot.lds
```

典型内容：

```lds
OUTPUT_FORMAT("elf64-littleaarch64")
OUTPUT_ARCH(aarch64)
ENTRY(_start)

SECTIONS
{
    . = 0x00200000;                    /* Rockchip 加载地址 */

    .text : {
        *(.__image_copy_start)
        *(.vectors)                     /* 异常向量 */
        arch/arm/cpu/armv8/start.o(.text*)  /* 启动代码 */
        *(.text*)
    }

    .rodata : { *(.rodata*) }
    .data : { *(.data*) }

    .bss : {
        __bss_start = .;
        *(.bss*)
        __bss_end = .;
    }

    /DISCARD/ : { *(.dynsym) *(.dynstr*) }  /* 丢弃无用段 */
}
```

---

## 二、CPU复位后跳转机制

### 2.1 硬件层面的复位过程

**这不是软件跳转，而是硬件强制复位**：

```
CPU复位时的硬件行为：
1. 复位信号拉低 → CPU内部所有寄存器清零
2. 程序计数器(PC)被硬件电路强制设置为固定值
3. ARM64架构规定：PC = 0xFFFF0000 (复位向量地址)
4. CPU开始从这个地址取指令执行
```

### 2.2 地址总线的实际操作

```
物理过程：
┌─────────┐
│   CPU   │
│  PC=0x  │──┬─ 地址总线(32/64位) ─→ 0xFFFF0000
│  FFFF   │  │
│  0000   │  └─ 片选信号(CS) ──────→ BootROM片选
└─────────┘
              ↓
        ┌─────────────┐
        │  BootROM    │ ← 这个芯片被激活
        │  (掩膜ROM)  │
        └─────────────┘
        ┌─────────────┐
        │    SRAM     │ ← 片选信号未激活
        └─────────────┘
        ┌─────────────┐
        │    DDR      │ ← 片选信号未激活(且未初始化)
        └─────────────┘
```

### 2.3 RK3399的实际内存映射

```c
// 复位时的内存映射
0xFFFF0000 - 0xFFFFFFFF : BootROM (固化在芯片内)
0xFF8C0000 - 0xFF8DFFFF : SRAM (128KB片上内存)
0x00000000 - 0xFFFFFFFF : DDR (需要初始化后才能用)
```

CPU发出地址 `0xFFFF0000` 时：
1. 地址解码器识别高位 `0xFFFF`
2. 激活 BootROM 的片选引脚（CS）
3. BootROM 输出该地址的数据到数据总线
4. CPU 读取第一条指令

---

## 三、代码顺序为什么重要？

### 3.1 误区：程序不是"从头到尾一行行执行"

**程序包含多个"入口点"**，不只是 `main()`：

```
嵌入式固件的执行流程：
┌────────────────────────────────────┐
│ 地址 0x200000: _start (汇编代码)   │ ← CPU跳到这里
│   1. 关闭中断                       │
│   2. 设置异常向量表                 │
│   3. 初始化栈指针                   │
│   4. 清零BSS段                      │
│   5. 跳转到 main()                  │
└────────────────────────────────────┘
         ↓ (跳转)
┌────────────────────────────────────┐
│ 地址 ???: main()                   │
│   初始化硬件、启动Linux内核         │
└────────────────────────────────────┘
         ↑
         │ (中断发生时)
┌────────────────────────────────────┐
│ 地址 0x200200: 中断向量表          │ ← 硬件自动跳转
│   +0x000: Reset                    │
│   +0x080: IRQ 中断                 │
│   +0x100: FIQ 中断                 │
│   +0x180: SError                   │
└────────────────────────────────────┘
```

### 3.2 错误代码顺序导致的问题

#### 问题1：启动代码不在开头

```lds
/* 错误的链接脚本 */
SECTIONS {
    .text : {
        *(.text)          /* 编译器按文件名字母顺序排列 */
    }
}
```

可能的结果：
```
0x200000: [drivers/serial.o 的代码]  ← BootROM跳到这里
0x201000: [arch/arm/cpu/armv8/start.o] ← _start在这里
```

CPU执行 `0x200000` 地址的 `serial.c` 代码，但此时：
- **栈未初始化** → 函数调用会写入随机地址
- **BSS未清零** → 全局变量是垃圾值
- **MMU未配置** → 内存访问可能失败

#### 问题2：异常向量表位置错误

ARM64要求异常向量表**必须 2KB 对齐**：

```c
// U-Boot启动代码 (arch/arm/cpu/armv8/start.S)
.align 11                    /* 2^11 = 2048字节对齐 */
vectors:
    .align 7
    b    _do_bad_sync        /* 偏移 0x000: Synchronous异常 */
    .align 7
    b    _do_bad_irq         /* 偏移 0x080: IRQ中断 */
    .align 7
    b    _do_bad_fiq         /* 偏移 0x100: FIQ中断 */
    .align 7
    b    _do_bad_error       /* 偏移 0x180: SError */

// 设置异常向量寄存器
ldr x0, =vectors
msr vbar_el3, x0            /* 告诉CPU：异常向量表在这里 */
```

如果链接脚本不保证 `.vectors` 段在正确位置：
```
# 错误情况
0x200100: vectors异常向量表  ← 未对齐到2KB边界

# CPU发生IRQ中断时
硬件计算: vbar_el3 + 0x080 = 0x200100 + 0x080 = 0x200180
CPU跳转到 0x200180，执行错误的指令
→ 系统崩溃
```

#### 问题3：位置相关代码（PIC）

早期启动代码在**重定位之前**运行，此时代码地址不确定：

```armasm
/* arch/arm/cpu/armv8/start.S */
_start:
    /* 此时运行地址 = 0xFF8C0000 (SRAM) */
    /* 但链接地址 = 0x00200000 (DDR)   */

    /* 错误：绝对地址访问 */
    ldr x0, =global_var      /* 生成：LDR x0, =0x00200300 */
    ldr x1, [x0]             /* 访问DDR，但DDR未初始化！崩溃 */

    /* 正确：PC相对寻址 */
    adr x0, global_var       /* 生成：ADR x0, PC+offset */
    ldr x1, [x0]             /* 访问实际运行地址 */
```

链接脚本必须保证位置相关代码在前：

```lds
.text : {
    *(.text.early)     /* 早期代码，使用PC相对寻址 */
    *(.text)           /* 重定位后的普通代码 */
}
```

---

## 四、RK3399 内存布局与分阶段启动

### 4.1 完整内存映射

```
物理地址空间：
0x00000000 ┌──────────────────────┐
           │    未使用/保留        │
0x00200000 ├──────────────────────┤ ← U-Boot加载地址(需DDR初始化)
           │    DDR (4GB)         │
0xFFFFFFFF ├──────────────────────┤
           │    ...               │
0xFF8C0000 ├──────────────────────┤ ← SRAM (片上内存，无需初始化)
           │  SRAM (128KB)        │
0xFF8DFFFF ├──────────────────────┤
           │    外设寄存器         │
0xFEC00000 ├──────────────────────┤
           │    GIC中断控制器      │
0xFFFF0000 ├──────────────────────┤
           │  BootROM (64KB)      │ ← 复位时从这里启动
0xFFFFFFFF └──────────────────────┘
```

### 4.2 为什么不能直接使用DDR？

**DDR需要复杂的初始化流程**：

```c
// DDR初始化步骤 (rkbin/bin/rk33/rk3399_ddr_*.bin)
1. 配置DDR PHY时序参数
2. 训练数据眼图(Data Eye Training)
3. 校准ZQ阻抗
4. 配置DDR控制器寄存器(上百个)
5. 执行内存测试验证稳定性

// 耗时：~100ms
```

### 4.3 三阶段启动流程

```
阶段1: BootROM (0xFFFF0000)
├─ 运行介质: 片上掩膜ROM (32KB代码)
├─ 可用内存: 无 (只有CPU寄存器)
├─ 任务: 从SD卡/eMMC加载 idbloader.img 到SRAM
└─ 时长: ~10ms

阶段2: SPL/TPL in SRAM (0xFF8C0000)
├─ 运行介质: SRAM (128KB)
├─ 可用内存: SRAM
├─ 任务: 初始化DDR、加载U-Boot到DDR
└─ 时长: ~100ms

阶段3: U-Boot in DDR (0x00200000)
├─ 运行介质: DDR (4GB)
├─ 可用内存: DDR
├─ 任务: 初始化外设、加载Linux内核
└─ 时长: ~2秒
```

### 4.4 地址 0x00200000 的含义

**不是"跳过SRAM"，而是DDR的物理起始地址**：

```c
/* RK3399 数据手册 */
DDR控制器基地址: 0x00000000
可用DDR起始:     0x00200000  (前2MB保留给BootROM使用)

/* 链接脚本中 */
. = 0x00200000;   // U-Boot链接到这个DDR地址
```

**关键点**：SRAM在 **完全不同的地址空间** `0xFF8C0000`，与DDR不冲突。

---

## 五、BootROM需要的特殊镜像格式

### 5.1 普通程序 vs U-Boot固件

#### 普通Linux程序的ELF格式

```bash
# 普通程序的ELF格式
readelf -l /bin/ls

Program Headers:
  Type           Offset   VirtAddr           FileSiz  MemSiz   Flg
  LOAD           0x000000 0x0000000000400000 0x1a2c8  0x1a2c8  R E  # 代码段
  LOAD           0x01a2c8 0x000000000061a2c8 0x00890  0x00bc0  RW   # 数据段
  DYNAMIC        0x01a2d8 0x000000000061a2d8 0x001f0  0x001f0  RW   # 动态链接
  NOTE           0x000238 0x0000000000400238 0x00044  0x00044  R    # 构建信息
```

#### U-Boot镜像格式 (uboot.img)

```c
/* Rockchip 镜像头部结构 (uboot/tools/rockchip/boot_merger.c) */

偏移    大小    字段              值
0x0000  4字节   magic            0x0FF0AA55 (Rockchip魔数)
0x0004  2字节   chip_type        0x3399 (RK3399)
0x0006  4字节   load_addr        0x00200000 (加载地址)
0x000A  4字节   image_size       0x000F0000 (镜像大小)
0x000E  2字节   boot_flag        0x01
0x0010  4字节   crc32            [校验和]
0x0014  492字节 reserved         [保留]
0x0200  N字节   actual_code      [实际的U-Boot二进制]
```

### 5.2 BootROM的加载逻辑

参考 `uboot/tools/rockchip/loaderimage.c:577`，BootROM的处理流程：

```c
// Rockchip BootROM 伪代码
void bootrom_load_uboot() {
    uint32_t *header = (uint32_t *)0xFF8C0000;  // SRAM地址

    // 1. 从SD卡读取头部
    sd_read(0x4000, header, 512);  // 扇区64读取头部

    // 2. 验证魔数
    if (header[0] != 0x0FF0AA55) {
        panic("Invalid magic");
    }

    // 3. 验证芯片类型
    if (header[1] != 0x3399) {
        panic("Wrong chip");
    }

    // 4. 读取完整镜像
    uint32_t load_addr = header[2];  // 0x00200000
    uint32_t size = header[3];
    sd_read(0x4200, load_addr, size);  // 加载到DDR

    // 5. 校验CRC
    if (crc32(load_addr, size) != header[4]) {
        panic("CRC mismatch");
    }

    // 6. 跳转执行
    ((void(*)())load_addr)();  // 跳转到0x00200000
}
```

### 5.3 为什么普通程序不需要特殊格式？

```
普通Linux程序:
├─ 加载器: 内核加载器 (execve系统调用)
├─ 格式解析: 内核读取ELF头部
├─ 内存分配: 内核自动分配虚拟地址
├─ 重定位: 动态链接器处理
└─ 启动: 内核设置好一切后跳转到main()

U-Boot固件:
├─ 加载器: BootROM (几KB的简单代码)
├─ 格式解析: 只能识别自定义头部(太简单，不支持ELF)
├─ 内存分配: 固件自己管理物理内存
├─ 重定位: 固件自己重定位代码
└─ 启动: 从物理地址0x00200000直接执行
```

### 5.4 实际查看uboot.img

```bash
# 十六进制查看打包后的镜像
hexdump -C uboot/uboot.img | head -n 20

00000000  55 aa f0 0f 99 33 00 00  00 02 00 00 c8 1a 00 00  |U....3..........|
          ^^^^^^^^^ 魔数         ^^^^^ 芯片  ^^^^^^^ 加载地址
                                              ^^^^^^^ 大小

00000200  [U-Boot二进制代码开始]
          ├─ 0x200: _start 汇编代码
          ├─ 0x220: 异常向量表
          └─ ...
```

---

## 六、完整对比总结

### 6.1 关键维度对比

| 问题维度 | 普通程序 | U-Boot固件 |
|---------|---------|-----------|
| **启动方式** | 内核加载(execve) | CPU硬件复位 |
| **程序入口** | main() | _start (汇编) |
| **内存管理** | 内核分配虚拟地址 | 自己管理物理地址 |
| **代码顺序** | 无关紧要 | 严格要求 |
| **镜像格式** | ELF (复杂) | 自定义头部 (简单) |
| **重定位** | 动态链接器 | 自己重定位 |
| **异常处理** | 内核统一管理 | 自己设置向量表 |
| **地址空间** | 虚拟地址 | 物理地址 |
| **内存初始化** | 内核负责 | 自己初始化DDR |

### 6.2 链接脚本的核心价值

编译器**可以**链接普通程序，但**不能**满足嵌入式固件的苛刻要求：

1. **硬件决定地址** - CPU 复位后跳转到固定物理地址
2. **启动顺序关键** - 错误的代码顺序导致无法启动
3. **内存布局复杂** - SRAM/DDR/ROM 有不同用途和初始化时序
4. **镜像格式要求** - BootROM 需要特定的段结构和头部格式

链接脚本是硬件约束与软件实现之间的**契约**，这是嵌入式开发的核心技能之一。

---

## 七、相关文件参考

### 7.1 关键源码文件

```bash
# U-Boot链接脚本
arch/arm/cpu/armv8/u-boot.lds

# 启动汇编代码
arch/arm/cpu/armv8/start.S

# 打包工具源码
uboot/tools/rockchip/loaderimage.c:577
uboot/tools/rockchip/boot_merger.c
uboot/tools/rockchip/trust_merger.c:779
```

### 7.2 相关教程文档

- `uboot/固件打包原理深度解析.md` - 打包机制详解
- `uboot/docs/loader镜像打包教程.md` - Loader打包流程
- `uboot/docs/trust镜像打包教程.md` - Trust打包流程
- `uboot/docs/uboot镜像打包教程.md` - U-Boot打包流程

### 7.3 构建命令

```bash
# 查看U-Boot链接脚本
cat arch/arm/cpu/armv8/u-boot.lds

# 构建U-Boot
cd uboot
./make.sh rk3399

# 查看生成的镜像头部
hexdump -C uboot.img | head -n 20

# 查看ELF段信息
readelf -l u-boot
readelf -S u-boot
```

---

## 八、总结

本教程解答了嵌入式系统开发中最核心的问题：

1. **CPU如何启动** - 硬件复位向量、地址总线机制
2. **为什么需要链接脚本** - 精确控制内存布局、代码顺序
3. **代码顺序的重要性** - 启动代码、异常向量、位置相关代码
4. **内存布局分阶段** - BootROM → SRAM → DDR 的演进
5. **固件格式的特殊性** - Rockchip自定义头部 vs ELF格式

理解这些概念是深入学习嵌入式Linux系统、U-Boot移植、内核启动的基础。

---

**作者**: Claude Code
**日期**: 2025-12-17
**适用平台**: RK3399 / ARM64
**相关项目**: OrangePi RK3399 Build System
