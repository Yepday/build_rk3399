# RK3399 完整镜像拼接流程教程

## 目录
1. [概述](#概述)
2. [最终镜像结构](#最终镜像结构)
3. [拼接前的准备工作](#拼接前的准备工作)
4. [GPT分区表创建](#gpt分区表创建)
5. [固件写入流程](#固件写入流程)
6. [完整拼接命令示例](#完整拼接命令示例)
7. [启动流程与镜像的关系](#启动流程与镜像的关系)
8. [常见问题排查](#常见问题排查)

---

## 概述

### 什么是镜像拼接？

经过各个构建阶段后，我们得到了多个独立的固件文件：
```
构建输出文件：
├── uboot/
│   ├── idbloader.img     # DDR初始化 + Miniloader
│   ├── uboot.img         # U-Boot主镜像
│   └── trust.img         # ARM Trusted Firmware + OP-TEE
├── kernel/
│   └── boot.img          # Linux内核 + Device Tree + Initramfs
└── rootfs/
    └── (目录结构)         # 根文件系统
```

**镜像拼接**就是将这些独立的固件文件按照特定的**扇区位置**和**分区布局**，组装成一个完整的可启动镜像文件（.img）。

---

## 最终镜像结构

### 完整布局图

```
┌────────────────────────────────────────────────────────────────┐
│                      RK3399 镜像完整布局                         │
├─────────┬───────────┬─────────────┬──────────────────────────────┤
│ 扇区位置 │  大小     │  分区名称    │  内容说明                    │
├─────────┼───────────┼─────────────┼──────────────────────────────┤
│ 0-63    │ 32 KB     │ [保留区]     │ MBR/GPT保护区                │
├─────────┼───────────┼─────────────┼──────────────────────────────┤
│ 64      │ ~4 MB     │ [idbloader]  │ BootROM加载的第一阶段        │
│         │           │              │ - DDR初始化代码              │
│         │           │              │ - Miniloader                │
├─────────┼───────────┼─────────────┼──────────────────────────────┤
│ 24576   │ 4 MB      │ uboot分区    │ U-Boot主引导程序             │
│ ~32767  │           │              │ (GPT分区表记录)              │
├─────────┼───────────┼─────────────┼──────────────────────────────┤
│ 32768   │ 4 MB      │ trust分区    │ ARM Trusted Firmware        │
│ ~40959  │           │              │ - BL31 (ATF)                │
│         │           │              │ - BL32 (OP-TEE, 可选)        │
├─────────┼───────────┼─────────────┼──────────────────────────────┤
│ 49152   │ 32 MB     │ boot分区     │ Linux启动镜像                │
│ ~114687 │           │              │ - 内核(Image)                │
│         │           │              │ - 设备树(DTB)                │
│         │           │              │ - Initramfs                  │
├─────────┼───────────┼─────────────┼──────────────────────────────┤
│ 376832  │ ~数GB     │ rootfs分区   │ 根文件系统 (ext4)            │
│ ~末尾   │           │              │ - /bin, /lib, /etc...       │
│         │           │              │ - 用户空间完整环境            │
└─────────┴───────────┴─────────────┴──────────────────────────────┘

扇区大小：512 字节
扇区 64  = 32 KB 偏移
扇区 24576 = 12 MB 偏移
扇区 32768 = 16 MB 偏移
扇区 49152 = 24 MB 偏移
扇区 376832 = 184 MB 偏移
```

### 为什么是这样的布局？

| 问题 | 答案 |
|------|------|
| **为什么idbloader在扇区64？** | BootROM固定从扇区64（32KB）开始查找loader |
| **为什么uboot/trust要GPT分区？** | Miniloader会根据GPT分区表定位这些固件 |
| **为什么间隔这么大？** | 预留空间给固件升级，避免覆盖其他分区 |
| **为什么rootfs在184MB？** | 前面的分区加起来约80MB，留足升级空间 |

---

## 拼接前的准备工作

### 1. 检查必需的固件文件

```bash
# 检查所有固件是否已生成
cd $BUILD

# 检查U-Boot固件
ls -lh uboot/idbloader.img uboot/uboot.img uboot/trust.img

# 检查内核镜像
ls -lh kernel/boot.img

# 检查rootfs目录
ls $DEST/
```

**预期输出**：
```
-rw-r--r-- 1 user user 512K  idbloader.img
-rw-r--r-- 1 user user 1.0M  uboot.img
-rw-r--r-- 1 user user 2.0M  trust.img
-rw-r--r-- 1 user user 20M   boot.img
```

### 2. 计算镜像大小

```bash
# 根文件系统大小（KB）
ROOTFS_KB=$(du -s $DEST | awk '{print $1}')

# 镜像总大小（MB）= rootfs大小 + 前置分区大小 + 安全余量
TOTAL_SIZE=$(expr $ROOTFS_KB / 1024 + 184 + 400)

echo "镜像大小: ${TOTAL_SIZE} MB"
```

---

## GPT分区表创建

### 什么是GPT分区表？

**GPT (GUID Partition Table)** 是现代的分区表格式，相比MBR：
- 支持超过2TB的磁盘
- 支持128个主分区（MBR只支持4个）
- 每个分区有唯一的GUID
- 有校验和保护，更可靠

### 创建基础镜像文件

```bash
# 创建空白镜像文件（稀疏文件，不立即占用磁盘空间）
dd if=/dev/zero of=orangepi_rk3399.img bs=1M count=0 seek=${TOTAL_SIZE}

# 查看文件信息
ls -lh orangepi_rk3399.img  # 显示逻辑大小
du -h orangepi_rk3399.img   # 显示实际占用（初始很小）
```

**解释**：
- `if=/dev/zero` - 输入源为零字节流
- `of=...` - 输出到镜像文件
- `bs=1M` - 块大小1MB
- `count=0` - 不写入数据
- `seek=${TOTAL_SIZE}` - 移动到指定大小，创建稀疏文件

### 使用parted创建GPT分区表

```bash
# 1. 初始化GPT分区表
parted -s orangepi_rk3399.img mklabel gpt

# 2. 创建uboot分区（扇区24576~32767）
parted -s orangepi_rk3399.img unit s mkpart uboot 24576 32767

# 3. 创建trust分区（扇区32768~40959）
parted -s orangepi_rk3399.img unit s mkpart trust 32768 40959

# 4. 创建boot分区（扇区49152~114687）
parted -s orangepi_rk3399.img unit s mkpart boot 49152 114687

# 5. 创建rootfs分区（扇区376832~末尾-34扇区）
parted -s orangepi_rk3399.img unit s mkpart rootfs 376832 -- -34s

# 6. 查看分区表
parted orangepi_rk3399.img print
```

**参数说明**：
- `-s` - 脚本模式（不交互）
- `unit s` - 使用扇区（sector）作为单位
- `mkpart <名称> <起始> <结束>` - 创建分区
- `-- -34s` - 末尾保留34个扇区（GPT备份表）

### 设置rootfs分区UUID（可选）

```bash
# 使用gdisk设置固定UUID（便于/etc/fstab识别）
ROOT_UUID="614e0000-0000-4b53-8000-1d28000054a9"

gdisk orangepi_rk3399.img <<EOF
x            # 进入专家模式
c            # 修改分区GUID
4            # 选择第4个分区（rootfs）
${ROOT_UUID} # 输入UUID
w            # 写入更改
y            # 确认
EOF
```

**分区表最终结果**：
```
Number  Start    End       Size      Name
 1      24576    32767     4096KB    uboot
 2      32768    40959     4096KB    trust
 3      49152    114687    32MB      boot
 4      376832   末尾      ~数GB     rootfs
```

---

## 固件写入流程

### 核心命令：dd

`dd` (Data Duplicator) 是Linux下的低级数据复制工具，可以直接操作扇区。

**基本语法**：
```bash
dd if=<源文件> of=<目标文件> seek=<偏移扇区> conv=notrunc,fsync
```

**关键参数**：
- `if` (input file) - 输入文件
- `of` (output file) - 输出文件
- `seek` - 跳过输出文件的N个块（扇区）再开始写入
- `conv=notrunc` - 不截断输出文件（保持原大小）
- `conv=fsync` - 写入后立即同步到磁盘

### 1. 写入idbloader.img

```bash
# idbloader必须写在扇区64（32KB偏移）
dd if=$BUILD/uboot/idbloader.img \
   of=orangepi_rk3399.img \
   seek=64 \
   conv=notrunc
```

**为什么是扇区64？**
- BootROM硬编码从扇区64开始搜索loader
- 前64个扇区（32KB）保留给MBR/GPT保护区

### 2. 写入uboot.img

```bash
# uboot.img写入扇区24576（12MB偏移）
dd if=$BUILD/uboot/uboot.img \
   of=orangepi_rk3399.img \
   seek=24576 \
   conv=notrunc,fsync
```

**对应关系**：
- 扇区24576 = 12 MB
- 对应GPT分区表中的uboot分区起始位置

### 3. 写入trust.img

```bash
# trust.img写入扇区32768（16MB偏移）
dd if=$BUILD/uboot/trust.img \
   of=orangepi_rk3399.img \
   seek=32768 \
   conv=notrunc,fsync
```

**内容**：
- BL31 (ARM Trusted Firmware)
- BL32 (OP-TEE，可选)

### 4. 写入boot.img

```bash
# boot.img写入扇区49152（24MB偏移）
dd if=$BUILD/kernel/boot.img \
   of=orangepi_rk3399.img \
   seek=49152 \
   conv=notrunc,fsync
```

**内容**：
- Linux内核镜像（Image）
- 设备树（*.dtb）
- 初始化内存盘（initramfs）

### 5. 写入rootfs分区

**步骤A：创建ext4文件系统**
```bash
# 1. 创建rootfs镜像文件（临时）
ROOTFS_SIZE=$(expr $(du -s $DEST | awk '{print $1}') + 400 * 1024)
dd if=/dev/zero of=rootfs.ext4 bs=1M count=$(expr $ROOTFS_SIZE / 1024)

# 2. 格式化为ext4
mkfs.ext4 -O ^metadata_csum \
          -F \
          -b 4096 \
          -E stride=2,stripe-width=1024 \
          -L rootfs \
          rootfs.ext4
```

**参数解释**：
- `-O ^metadata_csum` - 禁用元数据校验和（兼容老内核）
- `-F` - 强制格式化（即使文件已存在）
- `-b 4096` - 块大小4KB
- `-E stride=2,stripe-width=1024` - RAID优化参数
- `-L rootfs` - 卷标设为"rootfs"

**步骤B：挂载并复制文件**
```bash
# 1. 创建挂载点
mkdir -p /tmp/rootfs_mount

# 2. 挂载ext4镜像
mount -t ext4 rootfs.ext4 /tmp/rootfs_mount

# 3. 复制根文件系统
cp -rfa $DEST/* /tmp/rootfs_mount/

# 4. 卸载
umount /tmp/rootfs_mount
```

**步骤C：写入到最终镜像**
```bash
# 写入rootfs到扇区376832（184MB偏移）
dd if=rootfs.ext4 \
   of=orangepi_rk3399.img \
   seek=376832 \
   conv=notrunc,fsync

# 删除临时文件
rm -f rootfs.ext4
```

---

## 完整拼接命令示例

### 自动化脚本

```bash
#!/bin/bash

# 配置变量
BUILD=/path/to/build
DEST=/path/to/rootfs
OUTPUT_IMAGE="orangepi_rk3399_complete.img"

# 分区扇区定义
LOADER1_START=64
UBOOT_START=24576
TRUST_START=32768
BOOT_START=49152
ROOTFS_START=376832

echo "=== 阶段1：计算镜像大小 ==="
ROOTFS_KB=$(du -s $DEST | awk '{print $1}')
IMG_SIZE=$(expr $ROOTFS_KB / 1024 + 184 + 400)
echo "镜像大小: ${IMG_SIZE} MB"

echo "=== 阶段2：创建基础镜像 ==="
dd if=/dev/zero of=${OUTPUT_IMAGE} bs=1M count=0 seek=${IMG_SIZE}

echo "=== 阶段3：创建GPT分区表 ==="
parted -s ${OUTPUT_IMAGE} mklabel gpt
parted -s ${OUTPUT_IMAGE} unit s mkpart uboot 24576 32767
parted -s ${OUTPUT_IMAGE} unit s mkpart trust 32768 40959
parted -s ${OUTPUT_IMAGE} unit s mkpart boot 49152 114687
parted -s ${OUTPUT_IMAGE} unit s mkpart rootfs 376832 -- -34s

echo "=== 阶段4：写入idbloader ==="
dd if=$BUILD/uboot/idbloader.img of=${OUTPUT_IMAGE} seek=${LOADER1_START} conv=notrunc
echo "✓ idbloader.img 写入完成"

echo "=== 阶段5：写入uboot.img ==="
dd if=$BUILD/uboot/uboot.img of=${OUTPUT_IMAGE} seek=${UBOOT_START} conv=notrunc,fsync
echo "✓ uboot.img 写入完成"

echo "=== 阶段6：写入trust.img ==="
dd if=$BUILD/uboot/trust.img of=${OUTPUT_IMAGE} seek=${TRUST_START} conv=notrunc,fsync
echo "✓ trust.img 写入完成"

echo "=== 阶段7：写入boot.img ==="
dd if=$BUILD/kernel/boot.img of=${OUTPUT_IMAGE} seek=${BOOT_START} conv=notrunc,fsync
echo "✓ boot.img 写入完成"

echo "=== 阶段8：创建并写入rootfs ==="
# 创建临时rootfs镜像
ROOTFS_SIZE=$(expr ${ROOTFS_KB} + 409600)
dd if=/dev/zero of=rootfs_temp.ext4 bs=1M count=$(expr ${ROOTFS_SIZE} / 1024)

# 格式化
mkfs.ext4 -O ^metadata_csum -F -b 4096 -E stride=2,stripe-width=1024 -L rootfs rootfs_temp.ext4

# 挂载并复制
mkdir -p /tmp/rootfs_mount
mount -t ext4 rootfs_temp.ext4 /tmp/rootfs_mount
cp -rfa $DEST/* /tmp/rootfs_mount/
umount /tmp/rootfs_mount
rmdir /tmp/rootfs_mount

# 写入镜像
dd if=rootfs_temp.ext4 of=${OUTPUT_IMAGE} seek=${ROOTFS_START} conv=notrunc,fsync
rm -f rootfs_temp.ext4
echo "✓ rootfs 写入完成"

echo "=== 阶段9：生成校验和 ==="
md5sum ${OUTPUT_IMAGE} > ${OUTPUT_IMAGE}.md5sum
echo "✓ 校验和生成完成"

echo "=== 完成！==="
ls -lh ${OUTPUT_IMAGE}
parted ${OUTPUT_IMAGE} print
```

### 实际执行效果

```
=== 阶段1：计算镜像大小 ===
镜像大小: 2048 MB

=== 阶段2：创建基础镜像 ===
0+0 records in
0+0 records out

=== 阶段3：创建GPT分区表 ===
Information: You may need to update /etc/fstab.

=== 阶段4：写入idbloader ===
1024+0 records in
1024+0 records out
524288 bytes (524 kB, 512 KiB) copied
✓ idbloader.img 写入完成

=== 阶段5：写入uboot.img ===
2048+0 records in
2048+0 records out
1048576 bytes (1.0 MB, 1.0 MiB) copied
✓ uboot.img 写入完成

...

Model:  (file)
Disk /path/to/orangepi_rk3399_complete.img: 2147MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number  Start   End     Size    Name
 1      12.6MB  16.8MB  4194kB  uboot
 2      16.8MB  21.0MB  4194kB  trust
 3      25.2MB  58.7MB  33.6MB  boot
 4      193MB   2147MB  1954MB  rootfs
```

---

## 启动流程与镜像的关系

### BootROM如何找到固件？

```
上电复位
  ↓
┌─────────────────────────────────────────┐
│ BootROM (芯片内部ROM，硬编码)             │
├─────────────────────────────────────────┤
│ 1. 初始化eMMC/SD卡控制器（低速模式）      │
│ 2. 从扇区64读取512字节                   │ ← 固定偏移！
│ 3. 检查魔数 0xFCDC8C3B (SD) 或           │
│         0x0FF0AA55 (eMMC)               │
│ 4. 如果匹配，读取idbloader头部信息       │
│ 5. 加载DDR Init到SRAM (0xFF8C0000)      │
│ 6. 执行DDR Init，初始化内存              │
│ 7. 加载Miniloader到DDR (0x00200000)     │
│ 8. 跳转到Miniloader执行                  │
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ Miniloader                              │
├─────────────────────────────────────────┤
│ 1. 读取GPT分区表（扇区1）                │ ← 使用分区表！
│ 2. 查找"uboot"分区，读取到DDR            │
│ 3. 查找"trust"分区，读取到DDR            │
│ 4. 跳转到Trust执行                       │
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ Trust (ATF BL31)                        │
├─────────────────────────────────────────┤
│ 1. 初始化TrustZone安全环境               │
│ 2. 加载OP-TEE（如果存在BL32）            │
│ 3. 跳转到U-Boot执行                      │
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ U-Boot                                  │
├─────────────────────────────────────────┤
│ 1. 读取GPT分区表                         │
│ 2. 查找"boot"分区，加载内核和DTB         │
│ 3. 设置bootargs（root=PARTUUID=...）    │ ← 使用rootfs UUID
│ 4. 启动Linux内核                         │
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ Linux Kernel                            │
├─────────────────────────────────────────┤
│ 1. 根据bootargs挂载rootfs分区            │
│ 2. 执行/sbin/init，启动用户空间          │
└─────────────────────────────────────────┘
```

### 关键点总结

| 固件 | 如何定位 | 依赖 |
|------|---------|------|
| **idbloader** | BootROM硬编码查找扇区64 | 无（硬件固定） |
| **uboot/trust** | Miniloader读取GPT分区表 | 需要正确的GPT分区表 |
| **boot** | U-Boot读取GPT分区表 | 需要正确的GPT分区表 |
| **rootfs** | 内核根据PARTUUID挂载 | 需要正确的分区UUID |

---

## 常见问题排查

### 问题1：启动卡在"DDR Init"

**现象**：
```
DDR Version 1.25 20210507
...
(卡住不动)
```

**可能原因**：
- idbloader.img写入位置错误
- idbloader.img损坏

**排查方法**：
```bash
# 1. 检查idbloader是否写在扇区64
dd if=orangepi_rk3399.img bs=512 skip=64 count=1 | hexdump -C | head

# 应该看到魔数（SD卡：3B 8C DC FC，eMMC：55 AA F0 0F）
```

**解决方法**：
```bash
# 重新写入idbloader
dd if=idbloader.img of=orangepi_rk3399.img seek=64 conv=notrunc
```

### 问题2：启动卡在"Loading Trust..."

**现象**：
```
U-Boot 2024.01-rc1 (Dec 07 2024)
...
Loading Trust firmware...
(卡住不动)
```

**可能原因**：
- trust分区位置错误
- GPT分区表损坏

**排查方法**：
```bash
# 1. 检查GPT分区表
parted orangepi_rk3399.img print

# 2. 检查trust分区起始位置是否为扇区32768
# 3. 检查trust.img是否写入正确位置
dd if=orangepi_rk3399.img bs=512 skip=32768 count=1 | hexdump -C | head
# 应该看到魔数 55 AA F0 0F
```

**解决方法**：
```bash
# 重新创建GPT分区表并写入trust
parted -s orangepi_rk3399.img unit s mkpart trust 32768 40959
dd if=trust.img of=orangepi_rk3399.img seek=32768 conv=notrunc,fsync
```

### 问题3：内核启动后找不到rootfs

**现象**：
```
[    1.234567] VFS: Cannot open root device "PARTUUID=614e0000-..." or unknown-block(0,0)
[    1.234568] Please append a correct "root=" boot option
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
```

**可能原因**：
- rootfs分区UUID不匹配
- rootfs未写入或损坏

**排查方法**：
```bash
# 1. 检查rootfs分区UUID
gdisk -l orangepi_rk3399.img
# 查看分区4的GUID是否为 614E0000-0000-4B53-8000-1D28000054A9

# 2. 检查U-Boot的bootargs
# 启动时观察U-Boot打印的bootargs参数
```

**解决方法**：
```bash
# 方法1：修改rootfs分区UUID
ROOT_UUID="614e0000-0000-4b53-8000-1d28000054a9"
gdisk orangepi_rk3399.img <<EOF
x
c
4
${ROOT_UUID}
w
y
EOF

# 方法2：重新写入rootfs
dd if=rootfs.ext4 of=orangepi_rk3399.img seek=376832 conv=notrunc,fsync
```

### 问题4：镜像写入SD卡/eMMC后无法启动

**可能原因**：
- 写入工具问题（Windows下需使用专用工具）
- 镜像损坏

**排查方法**：
```bash
# Linux下写入SD卡
sudo dd if=orangepi_rk3399.img of=/dev/sdX bs=4M status=progress
sudo sync

# 验证写入
sudo dd if=/dev/sdX bs=512 skip=64 count=1 | hexdump -C | head
```

**注意事项**：
- ❌ 不要使用 `cp` 命令复制镜像到SD卡
- ❌ 不要使用 `dd` 写入到分区（如 `/dev/sdX1`），应写入整个设备（`/dev/sdX`）
- ✅ 使用 `dd` 写入到整个设备
- ✅ Windows下使用 Win32DiskImager 或 Etcher

### 问题5：分区大小计算错误

**现象**：
```
parted: Error: The location 376832s is outside of the device /path/to/image.
```

**原因**：
镜像文件太小，无法容纳所有分区

**解决方法**：
```bash
# 1. 重新计算所需大小
ROOTFS_KB=$(du -s $DEST | awk '{print $1}')
# rootfs分区起始位置（MB）
ROOTFS_START_MB=$(expr 376832 \* 512 / 1024 / 1024)  # = 184 MB
# 镜像总大小（MB）
IMG_SIZE=$(expr ${ROOTFS_KB} / 1024 + ${ROOTFS_START_MB} + 400)

# 2. 重新创建镜像
dd if=/dev/zero of=orangepi_rk3399.img bs=1M count=0 seek=${IMG_SIZE}
```

---

## 总结

### 镜像拼接的核心步骤

1. **准备固件**：确保所有固件文件已生成
2. **创建空白镜像**：使用 `dd` 创建稀疏文件
3. **创建分区表**：使用 `parted` 创建GPT分区
4. **写入固件**：使用 `dd` 按扇区位置写入
5. **生成校验和**：使用 `md5sum` 验证完整性

### 关键技术点

| 技术 | 说明 |
|------|------|
| **扇区定位** | BootROM/Miniloader通过固定扇区位置查找固件 |
| **GPT分区表** | Miniloader/U-Boot通过分区名称查找固件 |
| **稀疏文件** | 节省磁盘空间，只在实际写入时分配空间 |
| **dd命令** | 低级数据复制，可精确控制写入位置 |

### 与其他教程的关系

```
文档体系：
├── 固件打包原理深度解析.md         ← 理论基础（为什么需要打包）
├── 固件生成教学文档.md             ← 单个固件生成（uboot/loader/trust）
├── uboot镜像打包教程.md           ← uboot.img详解
├── loader镜像打包教程.md          ← loader.bin详解
├── trust镜像打包教程.md           ← trust.img详解
└── RK3399完整镜像拼接流程教程.md  ← 本文档（整体拼接流程）
```

**建议阅读顺序**：
1. 先读《固件打包原理深度解析》了解启动流程
2. 再读《固件生成教学文档》了解各个固件的生成
3. 最后读本文档，了解如何将固件组装成完整镜像

---

**文档版本**：v1.0
**最后更新**：2025-12-29
**作者**：Claude Sonnet 4.5
**适用平台**：OrangePi RK3399（理论适用于所有RK3399设备）
