# Rockchip 打包工具 C++ 面向对象重构设计方案

## 类层次结构设计

```cpp
// ========== 基类：抽象打包器 ==========
class RockchipPacker {
protected:
    // 共同的数据成员
    std::string inputPath;
    std::string outputPath;
    uint32_t imageSize;
    uint32_t numCopies;

    // 共同的辅助方法
    virtual void fixPath(std::string& path);
    virtual uint32_t calculateCRC32(const uint8_t* data, uint32_t size);
    virtual void alignData(uint8_t* data, uint32_t& size, uint32_t alignment);

public:
    virtual ~RockchipPacker() = default;

    // 模板方法：定义打包流程骨架
    bool pack() {
        if (!parseConfig()) return false;
        if (!buildHeader()) return false;
        if (!buildEntryTable()) return false;
        if (!writeData()) return false;
        if (!calculateChecksum()) return false;
        return true;
    }

    // 纯虚函数：子类必须实现
    virtual bool parseConfig() = 0;
    virtual bool buildHeader() = 0;
    virtual bool buildEntryTable() = 0;
    virtual bool writeData() = 0;
    virtual bool calculateChecksum() = 0;
    virtual bool unpack() = 0;
};

// ========== 子类 1：Boot Merger ==========
class BootMergerPacker : public RockchipPacker {
private:
    rk_boot_header header;
    std::vector<rk_boot_entry> entries;
    bool enableRC4;

protected:
    void encryptRC4(uint8_t* data, uint32_t size);

public:
    bool parseConfig() override {
        // 解析 INI 文件：[CHIP_NAME], [VERSION], [CODE471_OPTION]...
        // 对应 boot_merger.c:520 parseOpts_from_file()
        return true;
    }

    bool buildHeader() override {
        // 构建 rk_boot_header
        // 对应 boot_merger.c:1178 getBoothdr()
        header.tag = 0x544F4F42; // "BOOT"
        header.chipType = getChipType(opts.chip);
        return true;
    }

    bool buildEntryTable() override {
        // 构建 rk_boot_entry 数组
        // 对应 boot_merger.c:1339-1362
        for (auto& path : code471Paths) {
            entries.push_back(createEntry(path, ENTRY_471));
        }
        return true;
    }

    bool writeData() override {
        // 写入 CODE471 + CODE472 + Loader 数据
        // 对应 boot_merger.c:1365-1384
        for (auto& entry : entries) {
            writeFile(entry.path, entry.type == ENTRY_LOADER);
        }
        return true;
    }

    bool calculateChecksum() override {
        // 计算 CRC32
        // 对应 boot_merger.c:1226
        uint32_t crc = getCrc(outputPath);
        writeToFile(&crc, sizeof(crc));
        return true;
    }

    bool unpack() override;
};

// ========== 子类 2：Trust Merger ==========
class TrustMergerPacker : public RockchipPacker {
private:
    TRUST_HEADER header;
    std::vector<COMPONENT_DATA> componentData;
    std::vector<TRUST_COMPONENT> components;
    uint8_t shaMode;
    uint8_t rsaMode;

protected:
    bool filterELF(const std::string& path, std::vector<bl_entry_t>& entries);
    void calculateSHA256(uint8_t* hash, const uint8_t* data, uint32_t size);

public:
    bool parseConfig() override {
        // 解析 INI 文件：[BL30_OPTION], [BL31_OPTION]...
        // 对应 trust_merger.c:326 parseOpts()
        return true;
    }

    bool buildHeader() override {
        // 构建 TRUST_HEADER
        // 对应 trust_merger.c:750
        memcpy(&header.tag, "TRUS", 4);
        header.flags = (shaMode << 0) | (rsaMode << 4);
        return true;
    }

    bool buildEntryTable() override {
        // 构建 COMPONENT_DATA + TRUST_COMPONENT 双层表
        // 对应 trust_merger.c:772-789
        for (auto& entry : blEntries) {
            componentData.push_back({entry.addr, hashData});
            components.push_back({entry.id, storageAddr, imageSize});
        }
        return true;
    }

    bool writeData() override {
        // 写入 BL30/31/32/33 数据
        // 对应 trust_merger.c:851-871
        for (auto& entry : blEntries) {
            if (entry.isELF) {
                // ELF 文件：从指定偏移读取段
                readELFSegment(entry.path, entry.offset, entry.size);
            } else {
                // 二进制文件：整体读取
                readBinaryFile(entry.path);
            }
        }
        return true;
    }

    bool calculateChecksum() override {
        // 计算 SHA256 哈希（已在 buildEntryTable 中完成）
        return true;
    }

    bool unpack() override;
};

// ========== 子类 3：Loader Image ==========
class LoaderImagePacker : public RockchipPacker {
private:
    second_loader_hdr header;
    std::string imageType; // "uboot" or "trustos"

public:
    bool parseConfig() override {
        // 从命令行参数解析（不使用 INI 文件）
        // 对应 loaderimage.c:174-229
        return true;
    }

    bool buildHeader() override {
        // 构建 second_loader_hdr（2048 字节）
        // 对应 loaderimage.c:310-313
        memcpy(header.magic, magic, LOADER_MAGIC_SIZE);
        header.loader_load_addr = loadAddr;
        return true;
    }

    bool buildEntryTable() override {
        // loaderimage 无独立 Entry 表，跳过此步骤
        return true;
    }

    bool writeData() override {
        // 读取单个 bin 文件并写入
        // 对应 loaderimage.c:316-317
        readBinaryFile(inputPath);
        return true;
    }

    bool calculateChecksum() override {
        // 计算 CRC32 + SHA256
        // 对应 loaderimage.c:324, 353-366
        header.crc32 = crc32_rk(0, data, size);
        sha256_update(&ctx, data, size);
        return true;
    }

    bool unpack() override;
};

// ========== 工厂类 ==========
class PackerFactory {
public:
    static std::unique_ptr<RockchipPacker> createPacker(const std::string& type) {
        if (type == "boot") {
            return std::make_unique<BootMergerPacker>();
        } else if (type == "trust") {
            return std::make_unique<TrustMergerPacker>();
        } else if (type == "loader") {
            return std::make_unique<LoaderImagePacker>();
        }
        return nullptr;
    }
};
```

## 使用示例

```cpp
int main(int argc, char** argv) {
    // 1. 根据类型创建打包器
    auto packer = PackerFactory::createPacker("trust");

    // 2. 设置参数
    packer->setInputPath("RK3399TRUST.ini");
    packer->setOutputPath("trust.img");

    // 3. 执行打包（调用模板方法）
    if (!packer->pack()) {
        std::cerr << "Packing failed!" << std::endl;
        return -1;
    }

    std::cout << "Packing success!" << std::endl;
    return 0;
}
```

## 设计模式应用

### 1. **模板方法模式**（Template Method）
基类 `RockchipPacker::pack()` 定义了打包流程的骨架：
```cpp
parseConfig() → buildHeader() → buildEntryTable() →
writeData() → calculateChecksum()
```
子类实现各步骤的具体细节。

### 2. **工厂模式**（Factory）
`PackerFactory` 根据镜像类型创建对应的打包器实例。

### 3. **策略模式**（Strategy）
可以将加密算法（RC4、RSA）和哈希算法（CRC32、SHA256）抽象为策略接口：

```cpp
class ChecksumStrategy {
public:
    virtual ~ChecksumStrategy() = default;
    virtual uint32_t calculate(const uint8_t* data, uint32_t size) = 0;
};

class CRC32Strategy : public ChecksumStrategy {
public:
    uint32_t calculate(const uint8_t* data, uint32_t size) override {
        return crc32_rk(0, data, size);
    }
};

class SHA256Strategy : public ChecksumStrategy {
public:
    uint32_t calculate(const uint8_t* data, uint32_t size) override {
        // 返回 SHA256 哈希
    }
};
```

## 提取的公共功能

可以抽象到基类或独立工具类：

```cpp
class CommonUtils {
public:
    // 路径处理（对应 boot_merger.c:174, trust_merger.c:108）
    static void fixPath(std::string& path);

    // BCD 编码（对应 boot_merger.c:772, trust_merger.c:78）
    static uint32_t getBCD(uint16_t value);

    // 文件大小获取（对应 boot_merger.c:873, trust_merger.c:469）
    static bool getFileSize(const std::string& path, uint32_t& size);

    // 对齐计算
    static uint32_t alignTo(uint32_t value, uint32_t alignment);

    // 时间戳获取（对应 boot_merger.c:891）
    static rk_time getTime();
};
```

## 优点

1. **代码复用**：公共逻辑（路径处理、文件读写、对齐计算）只需实现一次
2. **扩展性强**：新增芯片类型（如 RK3588）只需添加新子类
3. **可测试性**：每个类可以独立单元测试
4. **类型安全**：编译期类型检查，减少运行时错误

## 缺点

1. **复杂度增加**：三个工具差异较大，强行抽象可能导致过度设计
2. **编译依赖**：嵌入式工具链对 C++ 支持可能不完善
3. **性能损耗**：虚函数调用有轻微开销（但对于文件 I/O 操作可忽略）
4. **生态不符**：U-Boot/Linux Kernel 都是 C 语言，引入 C++ 会显得格格不入

## 替代方案：C 语言重构（推荐）

如果要保持 C 语言，可以这样重构：

```c
// 定义函数指针表（模拟虚函数表）
typedef struct {
    bool (*parse_config)(void* ctx);
    bool (*build_header)(void* ctx);
    bool (*build_entry_table)(void* ctx);
    bool (*write_data)(void* ctx);
    bool (*calculate_checksum)(void* ctx);
} packer_ops_t;

// 通用打包上下文
typedef struct {
    char input_path[MAX_PATH];
    char output_path[MAX_PATH];
    const packer_ops_t* ops;  // 函数指针表
    void* private_data;        // 工具特定数据
} packer_ctx_t;

// 通用打包流程
bool pack_image(packer_ctx_t* ctx) {
    return ctx->ops->parse_config(ctx) &&
           ctx->ops->build_header(ctx) &&
           ctx->ops->build_entry_table(ctx) &&
           ctx->ops->write_data(ctx) &&
           ctx->ops->calculate_checksum(ctx);
}

// boot_merger 的实现
static const packer_ops_t boot_ops = {
    .parse_config = boot_parse_config,
    .build_header = boot_build_header,
    // ...
};

// 使用
packer_ctx_t ctx = {
    .ops = &boot_ops,
    // ...
};
pack_image(&ctx);
```

这种方式既保持了 C 语言生态的一致性，又实现了一定程度的抽象和复用。
